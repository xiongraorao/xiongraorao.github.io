<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>在路上</title>
  
  <subtitle>stay hungry, stay foolish!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xraorao.top/"/>
  <updated>2018-12-22T01:26:41.060Z</updated>
  <id>http://xraorao.top/</id>
  
  <author>
    <name>Xiong Raorao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python time和datetime模块的使用</title>
    <link href="http://xraorao.top/2018/12/21/python-time%E5%92%8Cdatetime%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://xraorao.top/2018/12/21/python-time和datetime模块的使用/</id>
    <published>2018-12-21T11:55:13.000Z</published>
    <updated>2018-12-22T01:26:41.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h1><ul><li><p>UTC time Coordinated Universal Time</p><p>世界协调时，又称 格林尼治天文时间、世界标准时间。与UTC time对应的是各个时区的local time，东N区的时间比UTC时间早N个小时，因此UTC time + N小时 即为东N区的本地时间；而西N区时间比UTC时间晚N个小时，即 UTC time - N小时 即为西N区的本地时间； 中国在东8区，因此比UTC时间早8小时，可以以UTC+8进行表示。</p></li><li><p>epoch time </p><p>表示时间开始的起点；它是一个特定的时间，不同平台上这个时间点的值不太相同，对于Unix而言，epoch time为 1970-01-01 00:00:00 UTC。</p></li><li><p>timestamp（时间戳） 也称为Unix时间 或 POSIX时间</p><p>它是一种时间表示方式，表示从格林尼治时间1970年1月1日0时0分0秒开始到现在所经过的毫秒数，其值为float类型。 但是有些编程语言的相关方法返回的是秒数（Python就是这样），这个需要看方法的文档说明。需要说明的是时间戳是个差值，其值与时区无关。</p></li></ul><h1 id="time-模块"><a href="#time-模块" class="headerlink" title="time 模块"></a>time 模块</h1><div class="table-container"><table><thead><tr><th style="text-align:left">方法/属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">time.altzone</td><td style="text-align:left">返回与utc时间的时间差，以秒为单位（西区该值为正，东区该值为负）。其表示的是本地DST 时区的偏移量，只有daylight非0时才使用。</td></tr><tr><td style="text-align:left">time.clock()</td><td style="text-align:left">返回当前进程所消耗的处理器运行时间秒数（不包括sleep时间），值为小数；该方法Python3.3改成了time.process_time()</td></tr><tr><td style="text-align:left">time.asctime([t])</td><td style="text-align:left">将一个tuple或struct_time形式的时间（可以通过gmtime()和localtime()方法获取）转换为一个24个字符的时间字符串，格式为: “Fri Aug 19 11:14:16 2016”。如果参数t未提供，则取localtime()的返回值作为参数。</td></tr><tr><td style="text-align:left">time.ctime([secs])</td><td style="text-align:left">功能同上，将一个秒数时间戳表示的时间转换为一个表示当前本地时间的字符串。如果参数secs没有提供或值为None，则取time()方法的返回值作为默认值。ctime(secs)等价于asctime(localtime(secs))</td></tr><tr><td style="text-align:left">time.time()</td><td style="text-align:left">返回时间戳（自1970-1-1 0:00:00 至今所经历的秒数）</td></tr><tr><td style="text-align:left">time.localtime([secs])</td><td style="text-align:left">返回以指定时间戳对应的本地时间的 struct_time对象（可以通过下标，也可以通过 .属性名 的方式来引用内部属性）格式</td></tr><tr><td style="text-align:left">time.localtime(time.time() + n*3600)</td><td style="text-align:left">返回n个小时后本地时间的 struct_time对象格式（可以用来实现类似crontab的功能）</td></tr><tr><td style="text-align:left">time.gmtime([secs])</td><td style="text-align:left">返回指定时间戳对应的utc时间的 struct_time对象格式（与当前本地时间差8个小时）</td></tr><tr><td style="text-align:left">time.gmtime(time.time() + n*3600)</td><td style="text-align:left">返回n个小时后utc时间的 struct_time对象（可以通过 .属性名 的方式来引用内部属性）格式</td></tr><tr><td style="text-align:left">time.strptime(time_str, time_format_str)</td><td style="text-align:left">将时间字符串转换为struct_time时间对象，如：time.strptime(‘2017-01-13 17:07’, ‘%Y-%m-%d %H:%M’)</td></tr><tr><td style="text-align:left">time.mktime(struct_time_instance)</td><td style="text-align:left">将struct_time对象实例转换成时间戳</td></tr><tr><td style="text-align:left">time.strftime(time_format_str, struct_time_instance)</td><td style="text-align:left">将struct_time对象实例转换成字符串</td></tr></tbody></table></div><p>time 的时间格式转换：</p><p><img src="/images/1063221-20170204153018854-1098926175.png" alt="time格式转换"></p><h1 id="datetime-模块"><a href="#datetime-模块" class="headerlink" title="datetime 模块"></a>datetime 模块</h1><p>datetime模块提供了处理日期和时间的类，既有简单的方式，又有复杂的方式。它虽然支持日期和时间算法，但其实现的重点是为输出格式化和操作提供高效的属性提取功能。</p><h2 id="datetime模块中定义的类"><a href="#datetime模块中定义的类" class="headerlink" title="datetime模块中定义的类"></a>datetime模块中定义的类</h2><p>datetime模块定义了以下几个类：</p><div class="table-container"><table><thead><tr><th style="text-align:left">类名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">datetime.date</td><td style="text-align:left">表示日期，常用的属性有：year, month和day</td></tr><tr><td style="text-align:left">datetime.time</td><td style="text-align:left">表示时间，常用属性有：hour, minute, second, microsecond</td></tr><tr><td style="text-align:left">datetime.datetime</td><td style="text-align:left">表示日期时间</td></tr><tr><td style="text-align:left">datetime.timedelta</td><td style="text-align:left">表示两个date、time、datetime实例之间的时间间隔，分辨率（最小单位）可达到微秒</td></tr><tr><td style="text-align:left">datetime.tzinfo</td><td style="text-align:left">时区相关信息对象的抽象基类。它们由datetime和time类使用，以提供自定义时间的而调整。</td></tr><tr><td style="text-align:left">datetime.timezone</td><td style="text-align:left">Python 3.2中新增的功能，实现tzinfo抽象基类的类，表示与UTC的固定偏移量</td></tr></tbody></table></div><h2 id="datetime模块中定义的常量"><a href="#datetime模块中定义的常量" class="headerlink" title="datetime模块中定义的常量"></a>datetime模块中定义的常量</h2><div class="table-container"><table><thead><tr><th style="text-align:left">常量名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">datetime.MINYEAR</td><td style="text-align:left">datetime.date或datetime.datetime对象所允许的年份的最小值，值为1</td></tr><tr><td style="text-align:left">datetime.MAXYEAR</td><td style="text-align:left">datetime.date或datetime.datetime对象所允许的年份的最大值，只为9999</td></tr></tbody></table></div><h2 id="datetime-datatime-类"><a href="#datetime-datatime-类" class="headerlink" title="datetime.datatime 类"></a>datetime.datatime 类</h2><p>class 定义：</p><pre><code>    class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None)</code></pre><h3 id="类方法和属性"><a href="#类方法和属性" class="headerlink" title="类方法和属性"></a>类方法和属性</h3><div class="table-container"><table><thead><tr><th>类方法/属性名称</th><th>描述</th></tr></thead><tbody><tr><td>datetime.today()</td><td>返回一个表示当前本期日期时间的datetime对象</td></tr><tr><td>datetime.now([tz])</td><td>返回指定时区日期时间的datetime对象，如果不指定tz参数则结果同上</td></tr><tr><td>datetime.utcnow()</td><td>返回当前utc日期时间的datetime对象</td></tr><tr><td>datetime.fromtimestamp(timestamp[, tz])</td><td>根据指定的时间戳创建一个datetime对象</td></tr><tr><td>datetime.utcfromtimestamp(timestamp)</td><td>根据指定的时间戳创建一个datetime对象</td></tr><tr><td>datetime.combine(date, time)</td><td>把指定的date和time对象整合成一个datetime对象</td></tr><tr><td>datetime.strptime(date_str, format)</td><td>将时间字符串转换为datetime对象</td></tr></tbody></table></div><h3 id="对象方法和属性"><a href="#对象方法和属性" class="headerlink" title="对象方法和属性"></a>对象方法和属性</h3><div class="table-container"><table><thead><tr><th>对象方法/属性名称</th><th>描述</th></tr></thead><tbody><tr><td>dt.year, dt.month, dt.day</td><td>年、月、日</td></tr><tr><td>dt.hour, dt.minute, dt.second</td><td>时、分、秒</td></tr><tr><td>dt.microsecond, dt.tzinfo</td><td>微秒、时区信息</td></tr><tr><td>dt.date()</td><td>获取datetime对象对应的date对象</td></tr><tr><td>dt.time()</td><td>获取datetime对象对应的time对象， tzinfo 为None</td></tr><tr><td>dt.timetz()</td><td>获取datetime对象对应的time对象，tzinfo与datetime对象的tzinfo相同</td></tr><tr><td>dt.replace([year[, month[, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]]]]])</td><td>生成并返回一个新的datetime对象，如果所有参数都没有指定，则返回一个与原datetime对象相同的对象</td></tr><tr><td>dt.timetuple()</td><td>返回datetime对象对应的tuple（不包括tzinfo）</td></tr><tr><td>dt.utctimetuple()</td><td>返回datetime对象对应的utc时间的tuple（不包括tzinfo）</td></tr><tr><td>dt.toordinal()</td><td>同date对象</td></tr><tr><td>dt.weekday()</td><td>同date对象</td></tr><tr><td>dt.isocalendar()</td><td>同date独享</td></tr><tr><td>dt.isoformat([sep])</td><td>返回一个‘%Y-%m-%d</td></tr><tr><td>dt.ctime()</td><td>等价于time模块的time.ctime(time.mktime(d.timetuple()))</td></tr><tr><td>dt.strftime(format)</td><td>返回指定格式的时间字符串</td></tr></tbody></table></div><p>datetime 时间格式转换：</p><p><img src="/images/1063221-20170205083810667-126583354.png" alt="datetime 时间格式转换"></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://blog.csdn.net/p9bl5bxp/article/details/54945920" target="_blank" rel="noopener">Python之日期与时间处理模块</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相关术语&quot;&gt;&lt;a href=&quot;#相关术语&quot; class=&quot;headerlink&quot; title=&quot;相关术语&quot;&gt;&lt;/a&gt;相关术语&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;UTC time Coordinated Universal Time&lt;/p&gt;
&lt;p&gt;世界协调时，又称 格
      
    
    </summary>
    
    
      <category term="python" scheme="http://xraorao.top/tags/python/"/>
    
      <category term="time" scheme="http://xraorao.top/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>python协程和异步</title>
    <link href="http://xraorao.top/2018/12/11/python%E5%8D%8F%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/"/>
    <id>http://xraorao.top/2018/12/11/python协程和异步/</id>
    <published>2018-12-11T06:21:03.000Z</published>
    <updated>2018-12-11T07:25:01.474Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ol><li><a href="#概念梳理">概念梳理</a><ol><li><a href="#协程">协程</a><ol><li><a href="#定义">定义</a></li><li><a href="#协程的实现方法">协程的实现方法</a></li></ol></li></ol></li><li><a href="#定义一个协程">定义一个协程</a></li><li><a href="#异步获取结果">异步获取结果</a></li><li><a href="#绑定回调函数">绑定回调函数</a></li><li><a href="#阻塞和await">阻塞和await</a></li><li><a href="#协程嵌套">协程嵌套</a></li><li><a href="#协程的挂起">协程的挂起</a></li><li><a href="#协程的停止">协程的停止</a></li><li><a href="#不同线程的事件循环">不同线程的事件循环</a></li><li><a href="#新线程协程">新线程协程</a></li></ol><!-- /TOC --><p><a id="markdown-概念梳理" name="概念梳理"></a></p><h1 id="概念梳理"><a href="#概念梳理" class="headerlink" title="概念梳理"></a>概念梳理</h1><p>Python 在3.4中引入了协程的概念，详见<a href="https://docs.python.org/3.6/library/asyncio.html" target="_blank" rel="noopener">asyncio</a></p><p><a id="markdown-协程" name="协程"></a></p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><a id="markdown-定义" name="定义"></a></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>协程，coroutine, 是一种用户态的轻量级线程。在调用一个函数的时候，可以发生中断，跳转到别的子程序执行，别的子程序也可以中断回来执行之前的子程序，这就是<code>协程</code></p><p>协程拥有自己的寄存器和上下文的栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。<strong>因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</strong></p><p>优点：</p><ol><li><p>无需线程上下文切换的开销，协程避免了无意义的调度，由此可以提高性能（但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力）</p></li><li><p>无需原子操作锁定及同步的开销</p></li><li>方便切换控制流，简化编程模型</li><li>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</li></ol><p>缺点：</p><ol><li>无法利用多核资源，本质上是单线程切换</li><li>阻塞操作的时候，会阻塞掉整个程序</li></ol><p><a id="markdown-协程的实现方法" name="协程的实现方法"></a></p><h3 id="协程的实现方法"><a href="#协程的实现方法" class="headerlink" title="协程的实现方法"></a>协程的实现方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"要开始啃骨头了..."</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(<span class="string">"\033[31;1m[consumer] %s\033[0m "</span> % name)</span><br><span class="line">        bone = <span class="keyword">yield</span></span><br><span class="line">        print(<span class="string">"[%s] 正在啃骨头 %s"</span> % (name, bone))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(obj1, obj2)</span>:</span></span><br><span class="line">    obj1.send(<span class="keyword">None</span>)    <span class="comment"># 启动obj1这个生成器,第一次必须用None  &lt;==&gt; obj1.__next__()</span></span><br><span class="line">    obj2.send(<span class="keyword">None</span>)    <span class="comment"># 启动obj2这个生成器,第一次必须用None  &lt;==&gt; obj2.__next__()</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        print(<span class="string">"\033[32;1m[producer]\033[0m 正在生产骨头 %s"</span> % n)</span><br><span class="line">        obj1.send(n)</span><br><span class="line">        obj2.send(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    con1 = consumer(<span class="string">"消费者A"</span>)</span><br><span class="line">    con2 = consumer(<span class="string">"消费者B"</span>)</span><br><span class="line">    producer(con1, con2)</span><br></pre></td></tr></table></figure><p>在asyncio中，使用async关键字来定义协程对象，这里的协程指的是能够异步返回结果的函数，通过事件循环机制来获取结果。</p><p><strong>asyncio中的关键字：</strong></p><p>event_loop 事件循环：程序开启一个无限循环，把一些函数注册到事件循环上，当满足事件发生的时候，调用相应的协程函数</p><p>coroutine 协程：协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。</p><p>task 任务：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含了任务的各种状态</p><p>future: 代表将来执行或没有执行的任务的结果。它和task上没有本质上的区别</p><p>async/await 关键字：python3.5用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口。</p><p><a id="markdown-定义一个协程" name="定义一个协程"></a></p><h1 id="定义一个协程"><a href="#定义一个协程" class="headerlink" title="定义一个协程"></a>定义一个协程</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 定义一个协程</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'add result: '</span>, a+b)</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">coroutine = add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">loop.run_until_complete(coroutine) <span class="comment"># 这里也可以返回执行结果</span></span><br><span class="line">print(<span class="string">'time: '</span>, time.time() - start)</span><br></pre></td></tr></table></figure><p>asyncio.get_event_loop：创建一个事件循环，然后使用run_until_complete将协程注册到事件循环，并启动事件循环</p><p><a id="markdown-异步获取结果" name="异步获取结果"></a></p><h1 id="异步获取结果"><a href="#异步获取结果" class="headerlink" title="异步获取结果"></a>异步获取结果</h1><p>过添加task来获取结果。<br>task添加有两种方法：</p><ul><li>loop.create_task(coroutine)创建task,</li><li>asyncio.ensure_future(coroutine)创建task</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 定义一个task，用于获取协程结果</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">coroutine = add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">task = loop.create_task(coroutine) <span class="comment"># 可以通过asyncio.ensure_future()来创建task</span></span><br><span class="line">print(task)</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line">print(task.result())</span><br><span class="line">print(<span class="string">'time: '</span>, time.time() - start)</span><br></pre></td></tr></table></figure><p><a id="markdown-绑定回调函数" name="绑定回调函数"></a></p><h1 id="绑定回调函数"><a href="#绑定回调函数" class="headerlink" title="绑定回调函数"></a>绑定回调函数</h1><p>绑定回调，在task执行完成的时候可以获取执行的结果，回调的最后一个参数是future对象，通过该对象可以获取协程返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start = time.time()</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop2 = asyncio.get_event_loop()</span><br><span class="line">print(<span class="string">'id diff: '</span>, id(loop), id(loop2)) <span class="comment"># 同一个线程占有相同的内存空间</span></span><br><span class="line">coroutine = add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#task = loop.create_task(coroutine) # 可以通过asyncio.ensure_future()来创建task</span></span><br><span class="line">task = asyncio.ensure_future(coroutine, loop=loop) <span class="comment"># loop 是线程特定，因此可以不用传递</span></span><br><span class="line">print(task)</span><br><span class="line">task.add_done_callback(callback)</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line">print(<span class="string">'time: '</span>, time.time() - start)</span><br></pre></td></tr></table></figure><p><a id="markdown-阻塞和await" name="阻塞和await"></a></p><h1 id="阻塞和await"><a href="#阻塞和await" class="headerlink" title="阻塞和await"></a>阻塞和await</h1><p>使用async可以定义协程对象，使用await可以针对耗时的操作进行挂起，就像生成器里的yield一样，函数让出控制权。协程遇到await，事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，再进行下一个协程的执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">async_add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="comment"># asyncio.sleep(1)</span></span><br><span class="line">    c = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> c &lt; <span class="number">1000000</span>:</span><br><span class="line">        c +=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Hello world: '</span>, <span class="string">'time='</span>, time.time())</span><br><span class="line">    r = <span class="keyword">await</span> async_add(<span class="number">1</span>, <span class="number">3</span>)  <span class="comment"># 模拟做别的事情</span></span><br><span class="line">    print(<span class="string">'异步返回的结果：'</span>, r, <span class="string">'time: '</span>, time.time())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait([hello() <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>)])) <span class="comment"># 使用await是因为run_until_complete 是一个阻塞的函数</span></span><br></pre></td></tr></table></figure><p><a id="markdown-协程嵌套" name="协程嵌套"></a></p><h1 id="协程嵌套"><a href="#协程嵌套" class="headerlink" title="协程嵌套"></a>协程嵌套</h1><p>使用async可以定义协程，协程用于耗时的io操作，我们也可以封装更多的io操作过程，这样就实现了嵌套的协程，即一个协程中await了另外一个协程，如此连接起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">now = <span class="keyword">lambda</span>: time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">"waiting:"</span>,x)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(x)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Done after &#123;&#125;s"</span>.format(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    coroutine1 = do_some_work(<span class="number">1</span>)</span><br><span class="line">    coroutine2 = do_some_work(<span class="number">2</span>)</span><br><span class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</span><br><span class="line">    tasks = [</span><br><span class="line">        asyncio.ensure_future(coroutine1),</span><br><span class="line">        asyncio.ensure_future(coroutine2),</span><br><span class="line">        asyncio.ensure_future(coroutine3)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    dones, pendings = <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> dones:</span><br><span class="line">        print(<span class="string">"Task ret:"</span>, task.result())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># results = await asyncio.gather(*tasks)</span></span><br><span class="line">    <span class="comment"># for result in results:</span></span><br><span class="line">    <span class="comment">#     print("Task ret:",result)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = now()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br><span class="line">print(<span class="string">"Time:"</span>, now()-start)</span><br></pre></td></tr></table></figure><p><a id="markdown-协程的挂起" name="协程的挂起"></a></p><h1 id="协程的挂起"><a href="#协程的挂起" class="headerlink" title="协程的挂起"></a>协程的挂起</h1><p>不在main协程函数里处理结果，直接返回await的内容，那么最外层的run_until_complete将会返回main协程的结果。 将上述的代码更改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">now = <span class="keyword">lambda</span>: time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">"waiting:"</span>,x)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(x)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Done after &#123;&#125;s"</span>.format(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    coroutine1 = do_some_work(<span class="number">1</span>)</span><br><span class="line">    coroutine2 = do_some_work(<span class="number">2</span>)</span><br><span class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</span><br><span class="line">    tasks = [</span><br><span class="line">        asyncio.ensure_future(coroutine1),</span><br><span class="line">        asyncio.ensure_future(coroutine2),</span><br><span class="line">        asyncio.ensure_future(coroutine3)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line">start = now()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">results = loop.run_until_complete(main())</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    print(<span class="string">"Task ret:"</span>,result)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Time:"</span>, now()-start)</span><br></pre></td></tr></table></figure><p>或者返回使用asyncio.wait方式挂起的协程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">now = <span class="keyword">lambda</span>: time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">"waiting:"</span>,x)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(x)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Done after &#123;&#125;s"</span>.format(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    coroutine1 = do_some_work(<span class="number">1</span>)</span><br><span class="line">    coroutine2 = do_some_work(<span class="number">2</span>)</span><br><span class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</span><br><span class="line">    tasks = [</span><br><span class="line">        asyncio.ensure_future(coroutine1),</span><br><span class="line">        asyncio.ensure_future(coroutine2),</span><br><span class="line">        asyncio.ensure_future(coroutine3)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line">start = now()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">done,pending = loop.run_until_complete(main())</span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> done:</span><br><span class="line">    print(<span class="string">"Task ret:"</span>,task.result())</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Time:"</span>, now()-start)</span><br></pre></td></tr></table></figure><p>也可以使用asyncio的as_completed方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">now = <span class="keyword">lambda</span>: time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">"waiting:"</span>,x)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(x)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Done after &#123;&#125;s"</span>.format(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    coroutine1 = do_some_work(<span class="number">1</span>)</span><br><span class="line">    coroutine2 = do_some_work(<span class="number">2</span>)</span><br><span class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</span><br><span class="line">    tasks = [</span><br><span class="line">        asyncio.ensure_future(coroutine1),</span><br><span class="line">        asyncio.ensure_future(coroutine2),</span><br><span class="line">        asyncio.ensure_future(coroutine3)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.as_completed(tasks):</span><br><span class="line">        result = <span class="keyword">await</span> task</span><br><span class="line">        print(<span class="string">"Task ret: &#123;&#125;"</span>.format(result))</span><br><span class="line"></span><br><span class="line">start = now()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br><span class="line">print(<span class="string">"Time:"</span>, now()-start)</span><br></pre></td></tr></table></figure><p><a id="markdown-协程的停止" name="协程的停止"></a></p><h1 id="协程的停止"><a href="#协程的停止" class="headerlink" title="协程的停止"></a>协程的停止</h1><p>协程的停止其实就是对future的停止，这个地方和concurrent包里面的futures差不多</p><p>future对象有几个状态：</p><ul><li>Pending</li><li>Running</li><li>Done</li><li>Cacelled</li></ul><p>创建future的时候，task为pending，事件循环调用执行的时候当然就是running，调用完毕自然就是done，如果需要停止事件循环，就需要先把task取消。可以使用asyncio.Task获取事件循环的task</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">now = <span class="keyword">lambda</span> :time.time()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">"Waiting:"</span>,x)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(x)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Done after &#123;&#125;s"</span>.format(x)</span><br><span class="line"></span><br><span class="line">coroutine1 =do_some_work(<span class="number">1</span>)</span><br><span class="line">coroutine2 =do_some_work(<span class="number">2</span>)</span><br><span class="line">coroutine3 =do_some_work(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future(coroutine1),</span><br><span class="line">    asyncio.ensure_future(coroutine2),</span><br><span class="line">    asyncio.ensure_future(coroutine3),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">start = now()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</span><br><span class="line">    print(asyncio.Task.all_tasks())</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.Task.all_tasks():</span><br><span class="line">        print(task.cancel())</span><br><span class="line">    loop.stop()</span><br><span class="line">    loop.run_forever()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    loop.close()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Time:"</span>,now()-start)</span><br></pre></td></tr></table></figure><p>启动事件循环之后，马上ctrl+c，会触发run_until_complete的执行异常 KeyBorardInterrupt。然后通过循环asyncio.Task取消future。可以看到输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Waiting: <span class="number">1</span></span><br><span class="line">Waiting: <span class="number">2</span></span><br><span class="line">Waiting: <span class="number">2</span></span><br><span class="line">^C&#123;&lt;Task finished coro=&lt;do_some_work() done, defined at /app/py_code/study_asyncio/simple_ex10.py:<span class="number">13</span>&gt; result=<span class="string">'Done after 1s'</span>&gt;, &lt;Task pending coro=&lt;do_some_work() running at /app/py_code/study_asyncio/simple_ex10.py:<span class="number">15</span>&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /usr/local/lib/python3<span class="number">.5</span>/asyncio/tasks.py:<span class="number">428</span>]&gt;, &lt;Task pending coro=&lt;do_some_work() running at /app/py_code/study_asyncio/simple_ex10.py:<span class="number">15</span>&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /usr/local/lib/python3<span class="number">.5</span>/asyncio/tasks.py:<span class="number">428</span>]&gt;, &lt;Task pending coro=&lt;wait() running at /usr/local/lib/python3<span class="number">.5</span>/asyncio/tasks.py:<span class="number">361</span>&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt;&gt;&#125;</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">Time: <span class="number">1.0707225799560547</span></span><br></pre></td></tr></table></figure><p>True表示cannel成功，loop stop之后还需要再次开启事件循环，最后在close，不然还会抛出异常</p><p>循环task，逐个cancel是一种方案，可是正如上面我们把task的列表封装在main函数中，main函数外进行事件循环的调用。这个时候，main相当于最外出的一个task，那么处理包装的main函数即可。</p><p><a id="markdown-不同线程的事件循环" name="不同线程的事件循环"></a></p><h1 id="不同线程的事件循环"><a href="#不同线程的事件循环" class="headerlink" title="不同线程的事件循环"></a>不同线程的事件循环</h1><p>很多时候，我们的事件循环用于注册协程，而有的协程需要动态的添加到事件循环中。一个简单的方式就是使用多线程。当前线程创建一个事件循环，然后在新建一个线程，在新线程中启动事件循环。当前线程不会被block。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">now = <span class="keyword">lambda</span> :time.time()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span><span class="params">(loop)</span>:</span></span><br><span class="line">    asyncio.set_event_loop(loop)</span><br><span class="line">    loop.run_forever()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">more_work</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">'More work &#123;&#125;'</span>.format(x))</span><br><span class="line">    time.sleep(x)</span><br><span class="line">    print(<span class="string">'Finished more work &#123;&#125;'</span>.format(x))</span><br><span class="line"></span><br><span class="line">start = now()</span><br><span class="line">new_loop = asyncio.new_event_loop()</span><br><span class="line">t = Thread(target=start_loop, args=(new_loop,))</span><br><span class="line">t.start()</span><br><span class="line">print(<span class="string">'TIME: &#123;&#125;'</span>.format(time.time() - start))</span><br><span class="line"></span><br><span class="line">new_loop.call_soon_threadsafe(more_work, <span class="number">6</span>)</span><br><span class="line">new_loop.call_soon_threadsafe(more_work, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>启动上述代码之后，当前线程不会被block，新线程中会按照顺序执行call_soon_threadsafe方法注册的more_work方法， 后者因为time.sleep操作是同步阻塞的，因此运行完毕more_work需要大致6 + 3</p><p><a id="markdown-新线程协程" name="新线程协程"></a></p><h1 id="新线程协程"><a href="#新线程协程" class="headerlink" title="新线程协程"></a>新线程协程</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">now = <span class="keyword">lambda</span> :time.time()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span><span class="params">(loop)</span>:</span></span><br><span class="line">    asyncio.set_event_loop(loop)</span><br><span class="line">    loop.run_forever()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">'Waiting &#123;&#125;'</span>.format(x))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(x)</span><br><span class="line">    print(<span class="string">'Done after &#123;&#125;s'</span>.format(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">more_work</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">'More work &#123;&#125;'</span>.format(x))</span><br><span class="line">    time.sleep(x)</span><br><span class="line">    print(<span class="string">'Finished more work &#123;&#125;'</span>.format(x))</span><br><span class="line"></span><br><span class="line">start = now()</span><br><span class="line">new_loop = asyncio.new_event_loop()</span><br><span class="line">t = Thread(target=start_loop, args=(new_loop,))</span><br><span class="line">t.start()</span><br><span class="line">print(<span class="string">'TIME: &#123;&#125;'</span>.format(time.time() - start))</span><br><span class="line"></span><br><span class="line">asyncio.run_coroutine_threadsafe(do_some_work(<span class="number">6</span>), new_loop)</span><br><span class="line">asyncio.run_coroutine_threadsafe(do_some_work(<span class="number">4</span>), new_loop)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#概念梳理&quot;&gt;概念梳理&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#协程&quot;&gt;协程&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#定义&quot;&gt;定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#协程的实现方法&quot;&gt;协程的实现方法
      
    
    </summary>
    
    
      <category term="python" scheme="http://xraorao.top/tags/python/"/>
    
      <category term="异步" scheme="http://xraorao.top/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>基于redis的分布式锁</title>
    <link href="http://xraorao.top/2018/12/08/%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://xraorao.top/2018/12/08/基于redis的分布式锁/</id>
    <published>2018-12-08T07:24:11.000Z</published>
    <updated>2018-12-11T02:21:20.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>分布式锁是控制分布式系统之间的同步访问共享资源的一种方式。</p><p>常规的Lock 和 Synchronized 只能在一个jvm中实现锁同步。</p><h2 id="分布式锁的条件"><a href="#分布式锁的条件" class="headerlink" title="分布式锁的条件"></a>分布式锁的条件</h2><ul><li>互斥性：分布式锁需要保证在不同节点的不同线程的互斥</li><li>可重入性：同一个节点上的同一个线程如果获取了锁之后，能够再次获取这个锁。</li><li>锁超时：支持超时释放锁，防止死锁</li><li>高效，高可用：加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。</li><li>支持阻塞和非阻塞：可以实现超时获取失败，tryLock(long timeOut)</li><li>支持公平锁和非公平锁</li></ul><h2 id="分布式锁的实现方案"><a href="#分布式锁的实现方案" class="headerlink" title="分布式锁的实现方案"></a>分布式锁的实现方案</h2><p>1、数据库实现（乐观锁）<br>2、基于zookeeper的实现<br>3、基于Redis的实现（推荐）<br>4、自研分布式锁：谷歌的chubby</p><h1 id="基于redis的分布式锁的实现"><a href="#基于redis的分布式锁的实现" class="headerlink" title="基于redis的分布式锁的实现"></a>基于redis的分布式锁的实现</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>1、 SETNX key value<br>如果 key 不存在，就试着key对应的字符串value</p><p>2、expire key seconds<br>设置key的过去时间，如果key过期，则会自动删除</p><p>3、del Key<br>删除这个key</p><h2 id="基本锁"><a href="#基本锁" class="headerlink" title="基本锁"></a>基本锁</h2><p>原理：利用redis的setnx，如果不存在某个key则设置，设置成功表示取得锁成功。<br>缺点：如果互斥锁后的进程在没有执行完就挂了，那么所永远不会被释放</p><p>==改进==<br>设置完setnx之后，利用expire操作保证超时后也能释放，但是setnx和expire不是一个原子操作，可能执行完setnx就挂了，需要使用Lua脚本来实现这个问题。</p><h2 id="开源实现"><a href="#开源实现" class="headerlink" title="开源实现"></a>开源实现</h2><p>Redisson 分布式可重如锁</p><p><a href="https://github.com/redisson/redisson" target="_blank" rel="noopener">https://github.com/redisson/redisson</a> </p><p>官网：<a href="http://redisson.org" target="_blank" rel="noopener">http://redisson.org</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;分布式锁是控制分布式系统之间的同步访问共享资源的一种方式。&lt;/p&gt;
&lt;p&gt;常规的Lock 和 Synchronized 只能在一个jvm中实
      
    
    </summary>
    
    
      <category term="redis" scheme="http://xraorao.top/tags/redis/"/>
    
      <category term="分布式锁" scheme="http://xraorao.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>python多线程和协程</title>
    <link href="http://xraorao.top/2018/11/15/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/"/>
    <id>http://xraorao.top/2018/11/15/python多线程和协程/</id>
    <published>2018-11-15T02:07:34.000Z</published>
    <updated>2018-11-15T09:27:45.047Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#多线程">多线程</a><ul><li><a href="#实现方法">实现方法</a></li><li><a href="#线程通信和线程同步">线程通信和线程同步</a></li><li><a href="#队列">队列</a></li></ul></li><li><a href="#协程">协程</a></li><li><a href="#参考文档">参考文档</a></li></ul><!-- /TOC --><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>python 中的多线程通常有两种实现方法，直接指定函数和继承线程类</p><ol><li>直接指定线程目标函数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'do something else'</span>)</span><br><span class="line"></span><br><span class="line">t = threading.Thread(target=run, args=())</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure><ol><li>继承线程类</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        super(MyThread, self).__init__()  <span class="comment"># 注意：一定要显式的调用父类的初始化函数。</span></span><br><span class="line">        self.arg = arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span>  <span class="comment"># 定义每个线程要运行的函数</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'the arg is:%s\r'</span> % self.arg)</span><br><span class="line">t = MyThread()</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure><h2 id="线程通信和线程同步"><a href="#线程通信和线程同步" class="headerlink" title="线程通信和线程同步"></a>线程通信和线程同步</h2><p>多线程通信可以通过多种方法，常见的有线程间的wait和notify机制，共享内存之类的。线程间的同步可以采用线程锁来实现</p><ol><li>通知等待机制</li></ol><p>首先看看java是如何实现线程wait 和 notify的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oceanai.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者和消费者实现.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiong Raorao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018-11-15-11:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProduceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Thread produceThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(q.size() &gt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">"[生产者]:队列已满，等待"</span>);</span><br><span class="line">              obj.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> val = (<span class="keyword">int</span>) (Math.random()*<span class="number">100</span>);</span><br><span class="line">            System.out.println(<span class="string">"[生产者]: 收到通知，继续生产。。。"</span>);</span><br><span class="line">            q.add(val);</span><br><span class="line">            System.out.println(<span class="string">"[生产者]: 生产: "</span> + val);</span><br><span class="line">            obj.notify();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread consumeThread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">"[消费者]:队列为空，等待"</span>);</span><br><span class="line">              obj.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"[消费者]:收到通知，继续消费"</span>);</span><br><span class="line">            <span class="keyword">int</span> val = q.poll();</span><br><span class="line">            System.out.println(<span class="string">"[消费者]:消费: "</span> + val);</span><br><span class="line">            obj.notify();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    produceThread.start();</span><br><span class="line">    consumeThread.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java的synchronized关键字绑定了一个对象锁,利用对象的wait()和notify()机制来实现消费者和生产者模型</p><p>由于Python对象没有隐式地和一个锁关联，因此需要利用Lock来实现,实现类为Condition</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-    </span></span><br><span class="line"><span class="keyword">import</span> threading  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Q</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.n=<span class="number">0</span>  </span><br><span class="line">        self.valueSet=<span class="keyword">False</span>  </span><br><span class="line">        <span class="comment">#相对于java,这里的要自己声明  </span></span><br><span class="line">        self.cv=threading.Condition()  </span><br><span class="line">          </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        cv=self.cv  </span><br><span class="line">        <span class="comment">#先得到锁  </span></span><br><span class="line">        cv.acquire()  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.valueSet:  </span><br><span class="line">            cv.wait()  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Got:"</span>,self.n  </span><br><span class="line">        self.valueSet=<span class="keyword">False</span>  </span><br><span class="line">        cv.notify()  </span><br><span class="line">        <span class="comment">#放弃锁  </span></span><br><span class="line">        cv.release()  </span><br><span class="line">        <span class="keyword">return</span> self.n  </span><br><span class="line">          </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self,n)</span>:</span>  </span><br><span class="line">        cv=self.cv  </span><br><span class="line">        <span class="comment">#先得到锁  </span></span><br><span class="line">        cv.acquire()  </span><br><span class="line">        <span class="keyword">if</span> self.valueSet:  </span><br><span class="line">            cv.wait()  </span><br><span class="line">        self.n=n;  </span><br><span class="line">        self.valueSet=<span class="keyword">True</span>  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Put:"</span>,n  </span><br><span class="line">        <span class="comment">#放弃锁  </span></span><br><span class="line">        cv.notify()  </span><br><span class="line">        cv.release()  </span><br><span class="line">          </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,q)</span>:</span>  </span><br><span class="line">        threading.Thread.__init__(self)  </span><br><span class="line">        self.q=q  </span><br><span class="line">        self.start()  </span><br><span class="line">          </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        i=<span class="number">0</span>  </span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="number">7</span>:  </span><br><span class="line">            i+=<span class="number">1</span>  </span><br><span class="line">            self.q.put(i)      </span><br><span class="line">              </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,q)</span>:</span>  </span><br><span class="line">        threading.Thread.__init__(self)  </span><br><span class="line">        self.q=q  </span><br><span class="line">        self.start()  </span><br><span class="line">          </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        i=<span class="number">0</span>  </span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="number">7</span>:  </span><br><span class="line">            i+=<span class="number">1</span>  </span><br><span class="line">            self.q.get()  </span><br><span class="line">              </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:  </span><br><span class="line">    q=Q()  </span><br><span class="line">    Producer(q)  </span><br><span class="line">    Consumer(q)</span><br></pre></td></tr></table></figure><ol><li>锁机制</li></ol><p>python 中的锁有两种实现，一种是<code>threading.Lock()</code>，另一种是<code>threading.RLock()</code>， 区别在于，RLock在同一个线程中可以多次被获取和释放，acquire和release函数需要成对出现。Lock在一个线程里面只能被获取一次，否则会发生死锁，一直等待。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">summary = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> summary</span><br><span class="line">    <span class="comment"># global lock</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        summary += <span class="number">1</span></span><br><span class="line">        summary -= <span class="number">1</span></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t = threading.Thread(target=add)</span><br><span class="line">        t.start()</span><br><span class="line">    print(<span class="string">'summary = '</span>, summary)</span><br><span class="line"></span><br><span class="line">start()</span><br></pre></td></tr></table></figure><p>使用with直接获取锁</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> summary</span><br><span class="line">    <span class="comment"># global lock</span></span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">            summary += <span class="number">1</span></span><br><span class="line">            summary -= <span class="number">1</span></span><br></pre></td></tr></table></figure><ol><li>守护线程</li></ol><p>python线程启动之前可以设置线程的<code>daemon</code>属性，默认Daemon为False。</p><p>Daemon = False: 当主线程执行完毕，会一直等待子线程执行完。<br>Daemon = True: 当主线程执行完毕，会立即结束程序。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>python 自带的queue实现了线程安全的队列，一共实现了三种队列：</p><ul><li>先进先出(FIFO)</li><li>后进先出(LIFO)</li><li>优先队列(Priority)</li></ul><p>常见方法：<br>Queue.Queue(maxsize=0)   FIFO， 如果maxsize小于1就表示队列长度无限<br>Queue.LifoQueue(maxsize=0)   LIFO， 如果maxsize小于1就表示队列长度无限<br>Queue.PriorityQueue(Queue)  优先队列，升序排列，要求Queue的元素为元组(priority number, data)<br>Queue.qsize()   返回队列的大小<br>Queue.empty()   如果队列为空，返回True,反之False<br>Queue.full()   如果队列满了，返回True,反之False<br>Queue.get([block[, timeout]])   读队列，timeout等待时间<br>Queue.put(item, [block[, timeout]])   写队列，timeout等待时间<br>Queue.queue.clear()   清空队列</p><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程：用户级别的线程，能够从函数A中断，然后跳转到另外一个函数执行，并且拥有自己的栈空间。</p><blockquote><p>线程是系统级别的，它们是由操作系统调度；协程是程序级别的，由程序员根据需要自己调度。我们把一个线程中的一个个函数叫做子程序，那么子程序在执行过程中可以中断去执行别的子程序；别的子程序也可以中断回来继续执行之前的子程序，这就是协程。</p></blockquote><p>协程的优缺点：</p><p><strong>协程的优点：</strong></p><p>　　（1）无需线程上下文切换的开销，协程避免了无意义的调度，由此可以提高性能（但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力）</p><p>　　（2）无需原子操作锁定及同步的开销</p><p>　　（3）方便切换控制流，简化编程模型</p><p>　　（4）高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</p><p><strong>协程的缺点：</strong></p><p>　　（1）无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。</p><p>　　（2）进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: "Zing-p"</span></span><br><span class="line"><span class="comment"># Date: 2017/5/12</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"要开始啃骨头了..."</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(<span class="string">"\033[31;1m[consumer] %s\033[0m "</span> % name)</span><br><span class="line">        bone = <span class="keyword">yield</span></span><br><span class="line">        print(<span class="string">"[%s] 正在啃骨头 %s"</span> % (name, bone))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(obj1, obj2)</span>:</span></span><br><span class="line">    obj1.send(<span class="keyword">None</span>)    <span class="comment"># 启动obj1这个生成器,第一次必须用None  &lt;==&gt; obj1.__next__()</span></span><br><span class="line">    obj2.send(<span class="keyword">None</span>)    <span class="comment"># 启动obj2这个生成器,第一次必须用None  &lt;==&gt; obj2.__next__()</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        print(<span class="string">"\033[32;1m[producer]\033[0m 正在生产骨头 %s"</span> % n)</span><br><span class="line">        obj1.send(n)</span><br><span class="line">        obj2.send(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    con1 = consumer(<span class="string">"消费者A"</span>)</span><br><span class="line">    con2 = consumer(<span class="string">"消费者B"</span>)</span><br><span class="line">    producer(con1, con2)</span><br></pre></td></tr></table></figure><p><img src="https://images2015.cnblogs.com/blog/986023/201705/986023-20170512144725551-803097173.png" alt="python实现协程"></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://www.cnblogs.com/zingp/p/5911537.html" target="_blank" rel="noopener">协程及Python中的协程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#多线程&quot;&gt;多线程&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#实现方法&quot;&gt;实现方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#线程通信和线程同步&quot;&gt;线程通信和线程同步&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="python" scheme="http://xraorao.top/tags/python/"/>
    
      <category term="多线程" scheme="http://xraorao.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python中的多进程</title>
    <link href="http://xraorao.top/2018/11/14/python%E4%B8%AD%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B/"/>
    <id>http://xraorao.top/2018/11/14/python中的子进程/</id>
    <published>2018-11-14T01:53:39.000Z</published>
    <updated>2018-12-06T08:03:03.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h1><h2 id="os包"><a href="#os包" class="headerlink" title="os包"></a>os包</h2><p>通常我们可以采用<code>os.system(cmd)</code> 或者<code>os.popen(cmd)</code>来调用系统命令。</p><ul><li>os.system(cmd): 返回值为0（成功执行）， 其实返回的是一个16位的二进制数，低8位为杀死所调用脚本的信号号码，高位为脚本的退出状态码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## test.sh</span></span><br><span class="line">echo <span class="string">'hello'</span></span><br><span class="line">exit <span class="number">3</span></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">ret = os.system(<span class="string">'./test.sh'</span>)</span><br><span class="line">ret = ret &gt;&gt; <span class="number">8</span></span><br><span class="line">print(ret) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>输出：<br>hello<br>3</p><ul><li>os.popen(cmd): 该种方法是通过管道的方式来实现命令调用，函数返回一个file-like对象，里面的内容是脚本的标准输出，可以通过read()函数来接收</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">ret = os.popen(<span class="string">'./test.sh'</span>)</span><br><span class="line">print(ret.read())</span><br></pre></td></tr></table></figure><p>输出：<br>hello</p><h2 id="subprocess"><a href="#subprocess" class="headerlink" title="subprocess"></a>subprocess</h2><p>对子进程进行更好的封装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub_proc2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'start subprocess'</span>)</span><br><span class="line">    p = sp.Popen([<span class="string">'nslookup'</span>], stdin=sp.PIPE, stdout=sp.PIPE, stderr=sp.PIPE)</span><br><span class="line">    out, err = p.communicate(bytes(<span class="string">'www.baidu.com'</span>, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line">    print(out.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    print(<span class="string">'exit'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sub_proc2()</span><br></pre></td></tr></table></figure><h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><h2 id="多进程的应用场景"><a href="#多进程的应用场景" class="headerlink" title="多进程的应用场景"></a>多进程的应用场景</h2><ol><li><p>多线程实现生产者和消费者模式（Queue）通信</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(q)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">if</span> q.full() <span class="keyword">is</span> <span class="keyword">False</span>:</span><br><span class="line">            val = count * count</span><br><span class="line">            print(<span class="string">'produce product: '</span>, val)</span><br><span class="line">            q.put(val)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        time.sleep(random.random()*<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">if</span> q.empty() <span class="keyword">is</span> <span class="keyword">False</span>:</span><br><span class="line">            print(<span class="string">'consume product: '</span>, q.get())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'q is empty'</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue(<span class="number">20</span>)</span><br><span class="line">    proc_produce = Process(target=produce, args=(q,))</span><br><span class="line">    proc_consume = Process(target=consume, args=(q,))</span><br><span class="line">    proc_produce.start()</span><br><span class="line">    proc_consume.start()</span><br></pre></td></tr></table></figure></li><li><p>使用Pipe通信</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue, Pipe</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc1</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        conn.send(i)</span><br><span class="line">        print(<span class="string">'send &#123;&#125; to pipe '</span>.format(i))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc2</span><span class="params">(conn)</span>:</span></span><br><span class="line">    n = <span class="number">9</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        result = conn.recv()</span><br><span class="line">        print(<span class="string">'receive &#123;&#125; from pip'</span>.format(result))</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p1, p2 = Pipe(<span class="keyword">True</span>) <span class="comment"># True 表示两个管道是全双工的，均可收发</span></span><br><span class="line">    process1 = Process(target=proc1, args=(p1,))</span><br><span class="line">    process2 = Process(target=proc2, args=(p2,))</span><br><span class="line">    process1.start()</span><br><span class="line">    process2.start()</span><br><span class="line">    process1.join()</span><br><span class="line">    process2.join()</span><br><span class="line">    p1.close()</span><br><span class="line">    p2.close()</span><br></pre></td></tr></table></figure><h2 id="多进程的启动"><a href="#多进程的启动" class="headerlink" title="多进程的启动"></a>多进程的启动</h2><ol><li>使用函数来启动多进程任务</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(interval)</span>:</span></span><br><span class="line">    n = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"The time is &#123;0&#125;"</span>.format(time.ctime()))</span><br><span class="line">        time.sleep(interval)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    p = multiprocessing.Process(target = worker, args = (<span class="number">3</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"p.pid:"</span>, p.pid</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"p.name:"</span>, p.name</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"p.is_alive:"</span>, p.is_alive()</span><br></pre></td></tr></table></figure><ol><li>使用类来定义多进程任务</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClockProcess</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, interval)</span>:</span></span><br><span class="line">        multiprocessing.Process.__init__(self)</span><br><span class="line">        self.interval = interval</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = <span class="number">5</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"the time is &#123;0&#125;"</span>.format(time.ctime()))</span><br><span class="line">            time.sleep(self.interval)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = ClockProcess(<span class="number">3</span>)</span><br><span class="line">    p.start()</span><br></pre></td></tr></table></figure><ol><li>使用进程池来启动多进程任务</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">print</span> msg</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"done "</span> + msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pool = multiprocessing.Pool(processes=<span class="number">4</span>)</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):</span><br><span class="line">        msg = <span class="string">"hello %d"</span> %(i)</span><br><span class="line">        result.append(pool.apply_async(func, (msg, )))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">print</span> res.get()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Sub-process(es) done."</span></span><br></pre></td></tr></table></figure><h2 id="获取进程的返回结果"><a href="#获取进程的返回结果" class="headerlink" title="获取进程的返回结果"></a>获取进程的返回结果</h2><ol><li>通过Queue让两个进程间通信</li><li>使用进程池子</li><li>通过Manager的方法来返回线程的值</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(procnum, return_dict)</span>:</span></span><br><span class="line">    <span class="string">'''worker function'''</span></span><br><span class="line">    <span class="keyword">print</span> str(procnum) + <span class="string">' represent!'</span></span><br><span class="line">    return_dict[procnum] = procnum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager = Manager()</span><br><span class="line">    return_dict = manager.dict()</span><br><span class="line">    jobs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = multiprocessing.Process(target=worker, args=(i,return_dict))</span><br><span class="line">        jobs.append(p)</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> proc <span class="keyword">in</span> jobs:</span><br><span class="line">        proc.join()</span><br><span class="line">    <span class="keyword">print</span> return_dict.values()</span><br></pre></td></tr></table></figure><h2 id="多进程的停止"><a href="#多进程的停止" class="headerlink" title="多进程的停止"></a>多进程的停止</h2><p>停止方法：process.terminate()</p><p>process.join() 值为了等待子进程结束后，主进程可以继续运行，通常用于进程间的同步</p><p>os.kill(pid,signal.SIGKILL) 该方法相当于kill -9，杀死进程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_forever</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        print(time.time())</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    p = Process(target=run_forever)</span><br><span class="line">    p.start()</span><br><span class="line">    print(<span class="string">'start a process.'</span>)</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> p.is_alive:</span><br><span class="line">        <span class="comment"># stop a process gracefully</span></span><br><span class="line">        p.terminate()</span><br><span class="line">        print(<span class="string">'stop process'</span>)</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line">    <span class="comment"># 如果主进程不停止，子线程就无法被杀死，会出现zombie 进程</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">      <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="Damon"><a href="#Damon" class="headerlink" title="Damon"></a>Damon</h2><p>damon 在process.start()之前使用才有效。<br>process.daemon = True # 表示当主进程结束的时候，子进程也会跟着结束</p><p>参考文档：</p><ul><li><a href="https://www.cnblogs.com/kaituorensheng/p/4445418.html" target="_blank" rel="noopener">Python 多进程编程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;子进程&quot;&gt;&lt;a href=&quot;#子进程&quot; class=&quot;headerlink&quot; title=&quot;子进程&quot;&gt;&lt;/a&gt;子进程&lt;/h1&gt;&lt;h2 id=&quot;os包&quot;&gt;&lt;a href=&quot;#os包&quot; class=&quot;headerlink&quot; title=&quot;os包&quot;&gt;&lt;/a&gt;os包&lt;/h
      
    
    </summary>
    
    
      <category term="python" scheme="http://xraorao.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ipython远程访问配置</title>
    <link href="http://xraorao.top/2018/11/06/ipython%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E9%85%8D%E7%BD%AE/"/>
    <id>http://xraorao.top/2018/11/06/ipython远程访问配置/</id>
    <published>2018-11-06T03:11:51.000Z</published>
    <updated>2018-11-06T04:12:14.695Z</updated>
    
    <content type="html"><![CDATA[<p>ubuntu 中实现ipython notebook的远程访问</p><h1 id="安装ipython-和-ipython-notebook"><a href="#安装ipython-和-ipython-notebook" class="headerlink" title="安装ipython 和 ipython notebook"></a>安装ipython 和 ipython notebook</h1><ol><li><p>安装 <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">Anoconda3</a></p><pre><code> bash ./Anoconda-xx.sh</code></pre></li><li><p>直接使用pip 安装</p><pre><code> pip install ipython  pip install notebook</code></pre></li></ol><h1 id="创建登录用户和密码"><a href="#创建登录用户和密码" class="headerlink" title="创建登录用户和密码"></a>创建登录用户和密码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> IPython.lib <span class="keyword">import</span> passwd</span><br><span class="line">In [<span class="number">2</span>]: passwd()</span><br><span class="line">Enter password:</span><br><span class="line">Verify password:</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">'sha1:026678de36b2:e4b83078e02c470b15789ade069359a20b0385dd'</span></span><br></pre></td></tr></table></figure><h1 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ipython profile create myserver</span><br><span class="line">cd ~/.ipython/profile_myserver/</span><br><span class="line">vim ipython_notebooke_config.py</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;&gt;&gt;</span></span><br><span class="line">c = get_config()</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Kernel config</span></span><br><span class="line">c.IPKernelApp.pylab = 'inline'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Notebook config</span></span><br><span class="line">c.NotebookApp.ip='*'</span><br><span class="line">c.NotebookApp.open_browser = False</span><br><span class="line">c.NotebookApp.password = u'sha1:026678de36b2:e4b83078e02c470b15789ade069359a20b0385dd'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> It<span class="string">'s a good idea to put it on a know,fixed port</span></span></span><br><span class="line">c.NotebookApp.port = 6789</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;</span><br></pre></td></tr></table></figure><h1 id="启动ipython服务器"><a href="#启动ipython服务器" class="headerlink" title="启动ipython服务器"></a>启动ipython服务器</h1><pre><code>    ipython notebook --config=~/.ipython/profile_myserver/ipython_notebook_config.py</code></pre><h1 id="ipython-notebook-设置多个虚拟环境"><a href="#ipython-notebook-设置多个虚拟环境" class="headerlink" title="ipython notebook 设置多个虚拟环境"></a>ipython notebook 设置多个虚拟环境</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找kernel.json的位置</span></span><br><span class="line">find . -name "kernel.json"</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;&lt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> xrr @ Cloud-06 <span class="keyword">in</span> ~ [11:53:53] </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">"kernel.json"</span></span></span><br><span class="line">./anaconda3/share/jupyter/kernels/python3/kernel.json</span><br><span class="line">./anaconda3/envs/py36/share/jupyter/kernels/python3/kernel.json</span><br><span class="line">./anaconda3/pkgs/ipykernel-4.9.0-py37_1/share/jupyter/kernels/python3/kernel.json</span><br><span class="line">(base) </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;&gt;</span></span><br><span class="line"></span><br><span class="line">cd ~/anaconda3/envs/py36/share/jupyter/kernels</span><br><span class="line">mkdir your_env_name &amp;&amp; cd your_env_name</span><br><span class="line">cp ../python3/kernel.json .</span><br><span class="line">vim kernel.json</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;</span><br><span class="line">&#123;</span><br><span class="line"> "argv": [</span><br><span class="line">  "/home/xrr/anaconda3/envs/py36/bin/python", # 替换为虚拟环境的python</span><br><span class="line">  "-m",</span><br><span class="line">  "ipykernel_launcher",</span><br><span class="line">  "-f",</span><br><span class="line">  "&#123;connection_file&#125;"</span><br><span class="line"> ],</span><br><span class="line"> "display_name": "py36", # 修改为你的虚拟环境的名称</span><br><span class="line"> "language": "python"</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><h1 id="jupyter-切换虚拟环境"><a href="#jupyter-切换虚拟环境" class="headerlink" title="jupyter 切换虚拟环境"></a>jupyter 切换虚拟环境</h1><p><img src="/images/dl/TIM截图20181106121037.jpg" alt=""></p><p><strong>Enjoy yourself！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ubuntu 中实现ipython notebook的远程访问&lt;/p&gt;
&lt;h1 id=&quot;安装ipython-和-ipython-notebook&quot;&gt;&lt;a href=&quot;#安装ipython-和-ipython-notebook&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="教程" scheme="http://xraorao.top/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="python" scheme="http://xraorao.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>神经网络和深度学习基础</title>
    <link href="http://xraorao.top/2018/10/30/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    <id>http://xraorao.top/2018/10/30/神经网络和深度学习基础/</id>
    <published>2018-10-30T06:24:37.000Z</published>
    <updated>2018-10-31T09:49:42.719Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#符号定义">符号定义</a></li><li><a href="#线性回归">线性回归</a><ul><li><a href="#梯度下降gradient-descent">梯度下降（Gradient Descent）</a></li><li><a href="#计算图">计算图</a></li><li><a href="#算法伪代码">算法伪代码</a></li><li><a href="#python-实现">python 实现</a></li></ul></li></ul><!-- /TOC --><h1 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h1><p>对于二分类的问题，假设输出$y$的值域为$\{0,1\}$, 输入的样本的数量为m，训练样本表示如下：</p><script type="math/tex; mode=display">\{(x^{(1)}, x^{(2)}, ... , x^{(m)}\}</script><p>假设每个样本的特征向量为n维， 将每个样本作为列向量，按照行方向堆叠，得到一个$n \cdot m$的矩阵, 其中$ X \in R^{n*m} $</p><script type="math/tex; mode=display">X = \begin{bmatrix}\vdots &\vdots &\vdots\\x_1 & x_2 & x_3\\\vdots & \vdots &\vdots \\\end{bmatrix}</script><h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><p>根据输入的样本，寻找一个线性函数$\hat y = f(x)$ 使得 $\hat y$的值更加接近$y$，通常表示如下：</p><script type="math/tex; mode=display">\hat y = w^Tx+b $$ 但是这个值有可能比0或者1相差太多，因此需要一个激活函数$\sigma(z) = \frac{1}{1+e^{-z}}$ 来将结果拉伸到0 ~ 1 之间。如下图：![](/images/dl/logistic.png)修正之后有：$$ \hat y = \sigma(w^Tx+b)</script><h2 id="梯度下降（Gradient-Descent）"><a href="#梯度下降（Gradient-Descent）" class="headerlink" title="梯度下降（Gradient Descent）"></a>梯度下降（Gradient Descent）</h2><p>如何求取w和b，使得$\hat y$的值更加接近于$y$？<br>采用梯度下降法来更新w和b，最终使得$\hat y$更加接近于$y$</p><p>$ \hat y = \sigma(w^Tx+b) $  — 回归函数<br>$ \sigma(z) = \frac{1}{1+e^{-z}} $ — 激活函数<br>$ L(\hat y, y) = -(y \log \hat y + (1-y)\log (1 - \hat y)) $ — 损失函数<br>$ J(w,b) = \frac{1}{m} \sum\limits_{i = 1 }^m L(\hat y^{(i)} + y{(i)})$ — 代价函数</p><p>有理论证明J(w,b)是关于w和b的凸函数，因此直接将J对w和b分别求导，令导数等于0，则得到的w和b即为所求的值，是的代价函数的值最小。</p><h2 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h2><p>计算图的概念比较好理解，类似于链式求导法则，前向计算，反向求导，后面一步总是可以利用前面一步的结果</p><p>下面来计算线性回归中的求导部分：</p><p>公式如下:</p><script type="math/tex; mode=display">z = w^Tx + b</script><script type="math/tex; mode=display">\hat y = a = \sigma(z) = \frac{1}{1+e^{-z}}</script><script type="math/tex; mode=display">L(a,y) = -(y\log a + (1-y)log(1-a))</script><p>这里令n=2,（假设输入的样本为二维向量）</p><p>则有前向计算公式:</p><ol><li>$ z = w_1 \cdot x_1 + w_2 \cdot x_1 + b $</li><li>$a = \sigma (z)$</li><li>$ L(a,y)$</li></ol><p>反向求导公式：</p><ol><li>$ da = \frac{\partial L(a,y)}{\partial a}$</li><li>$ dz= \frac{\partial L(a,y)}{\partial z} \\ = \frac{\partial L(a,y)}{\partial a} \cdot  \frac{\partial a}{\partial z} \\ = (- \frac {y}{a} + \frac{1-y}{1-a}) \cdot a \cdot (1-y) \\ = a-y$</li><li>$dw = \frac{\partial L(a,y)}{\partial w} \\ = dz \cdot \frac{\partial z}{\partial w} \\ = dz \cdot x $<br>$=&gt; dw_1 = x_1 \cdot dz, dw_2 = x_2 \cdot dz, dw_3 = x_3 \cdot dz$</li><li>$db = \frac{\partial L(a,y)}{\partial b} \\=dz \cdot \frac{\partial z}{\partial b} \\=dz$</li></ol><p>更新方法：</p><p>$ w_1:= w_1 - \alpha \cdot dw_1 $<br>$ w_2:= w_2 - \alpha \cdot dw_2 $<br>$ b:= b - \alpha \cdot db $</p><p>考虑m个样本的话，将损失函数替换为代价函数，然后求均值即可。</p><p>代价函数 = avg(损失函数)</p><p>$\frac{\partial J(w,b)}{\partial w}  = \frac{1}{m} \sum\limits_{i = 1 }^m \frac{\partial L(a^{(i)} + y{(i)})}{\partial w}$</p><p>$ w:= w - \alpha \cdot \frac{\partial{J(w,b)}}{\partial{w}} $<br>$ b:= b - \alpha \cdot \frac{\partial{J(w,b)}}{\partial{b}} $</p><h2 id="算法伪代码"><a href="#算法伪代码" class="headerlink" title="算法伪代码"></a>算法伪代码</h2><p>initialize $J = 0, dw_1 = 0, dw_2 = 0, db = 0$<br>for i = 1 to m:<br>    $z^{(i)}=w^T \cdot x^{(i)} + b$<br>    $J += -(y^{(i)} \log a^{(i)} + (1-y)\log (1 - a^{(i)}))$<br>    $dz^{(i)} = a^{(i)} - y^{(i)}$<br>    $dw_1 += x_1^i \cdot dz^{(i)}$<br>    $dw_2 += x_2^i \cdot dz^{(i)}$<br>    $db += dz^{(i)}$<br>end for<br>$J /= m$<br>$dw1 /= m$<br>$dw2 /= m$<br>$db /= m$<br>$w1 -= \alpha \cdot dw_1 $<br>$w2 -= \alpha \cdot dw_2 $<br>$b -= \alpha \cdot db $</p><h2 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>]])</span><br><span class="line">x = np.transpose(x)</span><br><span class="line">y = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]).reshape(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">J = <span class="number">0</span></span><br><span class="line">m = y.shape[<span class="number">0</span>]</span><br><span class="line">w = np.zeros([<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line">dw = np.zeros([<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line">db = np.zeros([<span class="number">3</span>,<span class="number">1</span>])</span><br><span class="line">b = np.zeros([<span class="number">3</span>,<span class="number">1</span>])</span><br><span class="line">epoch = <span class="number">100</span></span><br><span class="line">lr = <span class="number">0.001</span> <span class="comment"># 学习率</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, epoch):</span><br><span class="line">    z = np.dot(w.T,x) + b.T</span><br><span class="line">    a = <span class="number">1</span>/(<span class="number">1</span>+np.exp(-z))</span><br><span class="line">    J += np.sum(-(y*np.log(a)+(<span class="number">1</span>-y)*np.log(<span class="number">1</span>-a)))</span><br><span class="line">    dz = a.T - y</span><br><span class="line">    dw += np.dot(x, dz)</span><br><span class="line">    db += dz</span><br><span class="line">    dw /= m</span><br><span class="line">    db /= m</span><br><span class="line">    J /= m</span><br><span class="line">    print(<span class="string">'epoch: &#123;&#125; Loss = &#123;&#125;'</span>.format(i, J))</span><br><span class="line">    <span class="comment"># 更新权值</span></span><br><span class="line">    w -= lr*dw</span><br><span class="line">    b -= lr*db</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#符号定义&quot;&gt;符号定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#线性回归&quot;&gt;线性回归&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#梯度下降gradient-descent&quot;&gt;梯度下降（Gradient Desce
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://xraorao.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="deeplearning" scheme="http://xraorao.top/tags/deeplearning/"/>
    
  </entry>
  
  <entry>
    <title>聚类分析-python</title>
    <link href="http://xraorao.top/2018/10/26/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-python/"/>
    <id>http://xraorao.top/2018/10/26/聚类分析-python/</id>
    <published>2018-10-26T08:28:44.000Z</published>
    <updated>2018-10-30T12:26:56.745Z</updated>
    
    <content type="html"><![CDATA[<p>聚类根据方法大致可以分为以下几种：</p><p>（1）基于划分的方法：</p><p>给定一个有N个元组或者纪录的数据集，分裂法将构造K个分组，每一个分组就代表一个聚类，K&lt;N。 </p><p>算法：K-MEANS算法、K-MEDOIDS算法、CLARANS算法</p><p>（2） 基于层次的方法：</p><p>对给定的数据集进行层次似的分解，直到某种条件满足为止。具体又可分为“自底向上”和“自顶向下”两种方案。<br>特点：较小的计算开销。然而这种技术不能更正错误的决定。<br>算法：BIRCH算法、CURE算法、CHAMELEON算法</p><p>（3） 基于密度的方法</p><p>只要一个区域中的点的密度大过某个阈值，就把它加到与之相近的聚类中去。<br>特点：能克服基于距离的算法只能发现“类圆形”的聚类的缺点。<br>算法：DBSCAN算法、OPTICS算法、DENCLUE算法</p><p>（4）基于网络的方法</p><p>将数据空间划分成为有限个单元（cell）的网格结构,所有的处理都是以单个的单元为对象的。<br>特点：处理速度很快，通常这是与目标数据库中记录的个数无关的，只与把数据空间分为多少个单元有关。<br>算法：STING算法、CLIQUE算法、WAVE-CLUSTER算法</p><h1 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h1><h2 id="外部指标（有监督）"><a href="#外部指标（有监督）" class="headerlink" title="外部指标（有监督）"></a>外部指标（有监督）</h2><p>根据给定的数据集，然后做参考</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;聚类根据方法大致可以分为以下几种：&lt;/p&gt;
&lt;p&gt;（1）基于划分的方法：&lt;/p&gt;
&lt;p&gt;给定一个有N个元组或者纪录的数据集，分裂法将构造K个分组，每一个分组就代表一个聚类，K&amp;lt;N。 &lt;/p&gt;
&lt;p&gt;算法：K-MEANS算法、K-MEDOIDS算法、CLARANS算法&lt;
      
    
    </summary>
    
    
      <category term="python" scheme="http://xraorao.top/tags/python/"/>
    
      <category term="聚类" scheme="http://xraorao.top/tags/%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>深度学习(1)</title>
    <link href="http://xraorao.top/2018/10/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-1/"/>
    <id>http://xraorao.top/2018/10/25/深度学习-1/</id>
    <published>2018-10-25T01:27:37.000Z</published>
    <updated>2018-10-31T10:01:55.203Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#概要">概要</a></li><li><a href="#卷积神经网络cnn">卷积神经网络（CNN）</a><ul><li><a href="#卷积层">卷积层</a></li><li><a href="#dropout">DropOut</a></li><li><a href="#激活层">激活层</a></li><li><a href="#正则化层">正则化层</a></li><li><a href="#triplet-loss">Triplet Loss</a></li></ul></li></ul><!-- /TOC --><p>本系列日志为深度学习的笔记</p><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>深度学习</p><h1 id="卷积神经网络（CNN）"><a href="#卷积神经网络（CNN）" class="headerlink" title="卷积神经网络（CNN）"></a>卷积神经网络（CNN）</h1><h2 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h2><h2 id="DropOut"><a href="#DropOut" class="headerlink" title="DropOut"></a>DropOut</h2><p>为了提高CNN的特征表达能力，通常采用更深的网络和更多的神经元，但是复杂的网络容易导致过拟合，利用Dropout在一定程度上面可以防止过拟合</p><p><img src="https://images2015.cnblogs.com/blog/604152/201703/604152-20170330212327961-771136311.jpg" alt=""></p><p>如上图左，为没有Dropout的普通2层全连接结构，记为 r=a(Wv)，其中a为激活函数。</p><p>如上图右，为在第2层全连接后添加Dropout层的示意图。即在 模 型 训 练 时 随机让网络的某些节点不工作（输出置0），其它过程不变。</p><p>参考链接：</p><ul><li><a href="https://www.cnblogs.com/welhzh/p/6648613.html" target="_blank" rel="noopener">系列解读Dropout</a></li></ul><h2 id="激活层"><a href="#激活层" class="headerlink" title="激活层"></a>激活层</h2><p>Sigmoid 函数：$S(x) = \frac{1}{1+e^{-x}}$</p><h2 id="正则化层"><a href="#正则化层" class="headerlink" title="正则化层"></a>正则化层</h2><p>批量正则化:</p><script type="math/tex; mode=display">y = \frac{x - mean[x]}{ \sqrt{Var[x]} + \epsilon} * gamma + beta</script><h2 id="Triplet-Loss"><a href="#Triplet-Loss" class="headerlink" title="Triplet Loss"></a>Triplet Loss</h2><p>Triplet Loss 可以理解为三元损失，主要用于训练差异性较小的样本，如人脸等，Feed数据包括锚（Anchor）示例、正（Positive）示例、负（Negative）示例，通过优化锚示例与正示例的距离小于锚示例与负示例的距离，实现样本的相似性计算。</p><p><img src="https://upload-images.jianshu.io/upload_images/749674-36e5052fe9c91275?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt=""></p><p>目标函数如下：</p><script type="math/tex; mode=display">L = max(\sum\limits_{i}^{N}\Vert f(a_i^p) - f(x_i^p))\Vert^2 - \Vert f(a_i^p) - f(x_i^n))\Vert^2 + \alpha , 0)</script><p>由目标函数可以看出:</p><p>当x_a与x_n之间的距离 &lt; x_a与x_p之间的距离加$\alpha$时，[]内的值大于零，就会产生损失。</p><p>当x_a与x_n之间的距离 &gt;= x_a与x_p之间的距离加$\alpha$时，损失为零。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#概要&quot;&gt;概要&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#卷积神经网络cnn&quot;&gt;卷积神经网络（CNN）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#卷积层&quot;&gt;卷积层&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#d
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://xraorao.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="deeplearning" scheme="http://xraorao.top/tags/deeplearning/"/>
    
  </entry>
  
  <entry>
    <title>hexo 博客遇到的坑--host key verification failed</title>
    <link href="http://xraorao.top/2018/10/24/failed/"/>
    <id>http://xraorao.top/2018/10/24/failed/</id>
    <published>2018-10-24T00:44:39.000Z</published>
    <updated>2018-10-24T00:50:18.118Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>hexo d</code>进行部署的时候，会遇到如下的报错信息：</p><p>Host Key Verification failed ….</p><p>原因：ssh链接的时候没有加入到known_host 里面去，因此需要执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">The authenticity of host <span class="string">'github.com (192.30.252.1)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span></span><br><span class="line"><span class="string">are you sure you want to continue connecting (yes/no)?'</span></span><br><span class="line"></span><br><span class="line">yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有自己的服务器的话，同样需要执行</span></span><br><span class="line">ssh root@your.server.ip </span><br><span class="line"></span><br><span class="line">yes</span><br></pre></td></tr></table></figure><p>tips：遇到坑，先分析原因，分析不出来就google，==</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用&lt;code&gt;hexo d&lt;/code&gt;进行部署的时候，会遇到如下的报错信息：&lt;/p&gt;
&lt;p&gt;Host Key Verification failed ….&lt;/p&gt;
&lt;p&gt;原因：ssh链接的时候没有加入到known_host 里面去，因此需要执行如下命令：&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://xraorao.top/tags/hexo/"/>
    
      <category term="bug" scheme="http://xraorao.top/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>python学习笔记</title>
    <link href="http://xraorao.top/2018/10/23/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://xraorao.top/2018/10/23/python学习笔记/</id>
    <published>2018-10-23T03:11:20.000Z</published>
    <updated>2018-11-14T01:54:32.104Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#安装">安装</a><ul><li><a href="#python-解释器">python 解释器</a></li><li><a href="#ide">IDE</a></li></ul></li><li><a href="#函数">函数</a><ul><li><a href="#可变参数">可变参数</a></li><li><a href="#关键字参数">关键字参数</a></li></ul></li><li><a href="#高级特性">高级特性</a><ul><li><a href="#迭代">迭代</a></li><li><a href="#列表生成式">列表生成式</a></li><li><a href="#生成器">生成器</a></li></ul></li><li><a href="#函数式编程">函数式编程</a><ul><li><a href="#高阶函数">高阶函数</a></li></ul></li><li><a href="#面向对象">面向对象</a><ul><li><a href="#类属性和实例属性">类属性和实例属性</a></li><li><a href="#property装饰器">@property（装饰器）</a></li><li><a href="#异常处理">异常处理</a></li><li><a href="#调试">调试</a></li></ul></li><li><a href="#进程和线程">进程和线程</a><ul><li><a href="#多进程">多进程</a></li><li><a href="#多线程">多线程</a></li><li><a href="#threadlocal">ThreadLocal</a></li><li><a href="#协程">协程</a></li></ul></li><li><a href="#数组">数组</a><ul><li><a href="#切片">切片</a></li><li><a href="#索引">索引</a><ul><li><a href="#整数索引">整数索引</a></li><li><a href="#布尔索引">布尔索引</a></li></ul></li><li><a href="#副本和视图">副本和视图</a></li></ul></li><li><a href="#参考文档">参考文档</a></li></ul><!-- /TOC --><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">python 官网</a></p><p><a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">Anoconda(推荐)</a></p><h2 id="python-解释器"><a href="#python-解释器" class="headerlink" title="python 解释器"></a>python 解释器</h2><p>CPython: 命令行的python</p><p>ipython: CPython 的增强版，能够自动提示，有很多magic功能</p><p>PyPy: 采用JIT技术，动态编译代码，显著提高python的执行速度</p><p>Jython: 运行在Java平台的python解释器，可以把Python代码编译成Java字节码执行</p><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>Pycharm(推荐，可以支持远程解释执行)、Spider</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>python 不支持函数的重载，以后面的定义的函数为准。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a*a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(a,n)</span>:</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s*a</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p>当调用<code>power(5)</code>的时候，发现代码报错，原因是被后面的power函数给重定义了，第一个失效，因此采用默认参数来实现函数的重载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(a,n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s*a</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>必选参数需要放在前面，默认参数放在后面</li><li>变换大的参数放前面，变化小的参数放后面</li><li>默认参数必须指向不变对象（None, str,tuple)</li></ul><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>函数参数前面加一个星号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line">calc(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">calc(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Michael'</span>, <span class="number">30</span>)</span><br><span class="line">name: Michael age: <span class="number">30</span> other: &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Bob'</span>, <span class="number">35</span>, city=<span class="string">'Beijing'</span>)</span><br><span class="line">name: Bob age: <span class="number">35</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以自己对参数进行过滤</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'city'</span> <span class="keyword">in</span> kw:</span><br><span class="line">        <span class="comment"># 有city参数</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'job'</span> <span class="keyword">in</span> kw:</span><br><span class="line">        <span class="comment"># 有job参数</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br></pre></td></tr></table></figure><h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>采用 for + 可迭代对象的方式实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(items):</span><br><span class="line">    print(i, item)</span><br></pre></td></tr></table></figure><p>python 中如何判断对象的可迭代性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line">isinstance([], Iterable) <span class="comment"># True</span></span><br><span class="line">isinstance(<span class="number">1</span>, Iterable) <span class="comment"># False</span></span><br></pre></td></tr></table></figure><p><strong>可迭代对象的本质：</strong><br>可迭代对象通过 <code>__iter__</code>⽅法向我们提供⼀个迭代器，我们在迭代⼀个可迭代对象的时候，实际上就是先获取该对象提供的⼀个迭代器，然后通过这个迭代器来依次读取对象中的每⼀个数据。那么也就是说，⼀个具备了<code>__iter__</code>⽅法的对象，就是⼀个可迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>    <span class="title">MyList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.container    =    []                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,    item)</span>:</span></span><br><span class="line">        self.container.append(item)                   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回⼀个迭代器"""</span></span><br><span class="line">        <span class="comment">#    我们暂时忽略如何构造⼀个迭代器对象</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">mylist = MyList()</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line">isinstance(mylist, Iterable) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>python 内置的非常强大的用来创建list的生成式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选出偶数的平方</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># java语言的a&gt;b？a：b</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>列表生成式是一次性创建，而生成器可以边循环边创建,只需要把列表生成式的[]改成()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;g = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用next()函数获得generator的下一个返回值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="number">81</span></span><br><span class="line"><span class="comment"># 没有更多元素时候，抛出异常</span></span><br><span class="line">&gt;&gt;&gt;next(g)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>生成器遇到<code>yeild</code> 就会返回，再次执行<code>next()</code>函数就会从上次返回的yeild语句处继续执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">odd</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'step 1'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    print(<span class="string">'step 2'</span>)</span><br><span class="line">    <span class="keyword">yield</span>(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'step 3'</span>)</span><br><span class="line">    <span class="keyword">yield</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o = odd()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(o)</span><br><span class="line">step <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(o)</span><br><span class="line">step <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(o)</span><br><span class="line">step <span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(o)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>变量可以指向函数,例如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">f = math.cos</span><br><span class="line">print(f(<span class="number">5</span>))</span><br></pre></td></tr></table></figure></p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>将函数作为另一个函数的参数输入，该函数称为高阶函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y,f)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> f(x)+f(y)</span><br><span class="line"></span><br><span class="line">x = <span class="number">-5</span></span><br><span class="line">y = <span class="number">6</span></span><br><span class="line">f = abs</span><br><span class="line">print(add(x,y,f))</span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>dir(obj) : 查看对象的所有属性和方法<br>isinstance(obj, class): 判断obj对象是否是class类型<br>hasattr(obj, att) : 判断对象obj是否有att属性<br>getattr(obj, att) : 获取对象obj的att属性<br>setattr(obj, att) : 设置对象obj的att属性</p><h2 id="类属性和实例属性"><a href="#类属性和实例属性" class="headerlink" title="类属性和实例属性"></a>类属性和实例属性</h2><p>实例变量和类变量同名的话，实例变量会覆盖掉类变量<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    __slot__ = (<span class="string">'name'</span>,<span class="string">'sex'</span>) <span class="comment"># 使用turple来限制类能绑定的属性的名称</span></span><br><span class="line">    name = <span class="string">"sa"</span> <span class="comment"># 类属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name <span class="comment"># 实例属性, 覆盖掉类属性</span></span><br><span class="line">        self.sex = <span class="string">"male"</span> <span class="comment"># 实例属性</span></span><br><span class="line"></span><br><span class="line">a = A(<span class="string">"test"</span>)</span><br><span class="line">print(a.name) <span class="comment"># test</span></span><br><span class="line">print(A.name) <span class="comment"># sa</span></span><br><span class="line">dle a.name</span><br><span class="line">print(a.name) <span class="comment"># sa</span></span><br></pre></td></tr></table></figure></p><h2 id="property（装饰器）"><a href="#property（装饰器）" class="headerlink" title="@property（装饰器）"></a>@property（装饰器）</h2><p>对于私有变量，可以采用@property的方法实现把一个方法当做属性进行调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property # 负责把一个getter 方法编程属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter  # 负责把一个setter方法变成属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">        self._score = value</span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.score = <span class="number">60</span></span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>try … except … finally … 的错误处理机制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'try...'</span>)</span><br><span class="line">    r = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">    print(<span class="string">'result:'</span>, r)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'except:'</span>, e) <span class="comment"># 有异常发生的时候执行</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'no exceptions'</span>) <span class="comment"># 无异常发生的时候执行</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'finally...'</span>) <span class="comment"># 一定会执行</span></span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ol><li>print打印</li><li>assert 断言</li><li>logging 包</li><li>pdb 调试</li></ol><p><code>python -m pdb err.py</code> 启动调试模式，单步执行</p><p>或者在err.py里面使用pdb.set_trace()代码，使用python命令执行程序会自动在这一行进入pdb调试模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># err.py</span></span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line">s = <span class="string">'0'</span></span><br><span class="line">n = int(s)</span><br><span class="line">pdb.set_trace() <span class="comment"># 运行到这里会自动暂停</span></span><br><span class="line">print(<span class="number">10</span> / n)</span><br></pre></td></tr></table></figure><p>pdb 常用命令：<br>p 变量名： 查看变量<br>n ：单步执行代码<br>c ：执行到断点处</p><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>python 采用了GIL（Global Interpreter Lock）锁的机制,因此单进程多线程的程序只能利用一个CPU核心，想要跑满多核，需要采用多进程编程的方法来实现</p><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>采用 os.fork() 或者multiprocessing 的包来实现多进程</p><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431927781401bb47ccf187b24c3b955157bb12c5882d000" target="_blank" rel="noopener">参考链接</a></p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新线程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        print(<span class="string">'thread %s &gt;&gt;&gt; %s'</span> % (threading.current_thread().name, n))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=loop, name=<span class="string">'LoopThread'</span>)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>Python 也支持lock，也可以使用threadlocal 来实现线程之间变量的隔离</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>python 中的协程(Coroutine)是通过generator实现的。</p><p>优势：</p><ol><li>极高的执行效率，子程序之间不用线程切换，由程序自身控制，线程越多，协程的优势越明显</li><li>不需要多线程的锁机制。因此采用多进程+协程的方法，能够利用多核CPU的优势。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    r = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(<span class="string">'[CONSUMER] Consuming %s...'</span> % n)</span><br><span class="line">        r = <span class="string">'200 OK'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(c)</span>:</span></span><br><span class="line">    c.send(<span class="keyword">None</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        print(<span class="string">'[PRODUCER] Producing %s...'</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(<span class="string">'[PRODUCER] Consumer return: %s'</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">c = consumer()</span><br><span class="line">produce(c)</span><br></pre></td></tr></table></figure><p>asyncio 异步IO的支持</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hello world!"</span>)</span><br><span class="line">    <span class="comment"># 异步调用asyncio.sleep(1):</span></span><br><span class="line">    r = <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"Hello again!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取EventLoop:</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 执行coroutine</span></span><br><span class="line">loop.run_until_complete(hello())</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><p>@asyncio.coroutine把一个generator标记为coroutine类型，然后，我们就把这个coroutine扔到EventLoop中执行。</p><p>hello()会首先打印出Hello world!，然后，yield from语法可以让我们方便地调用另一个generator。由于asyncio.sleep()也是一个coroutine，所以线程不会等待asyncio.sleep()，而是直接中断并执行下一个消息循环。当asyncio.sleep()返回时，线程就可以从yield from拿到返回值（此处是None），然后接着执行下一行语句。</p><p>把asyncio.sleep(1)看成是一个耗时1秒的IO操作，在此期间，主线程并未等待，而是去执行EventLoop中其他可以执行的coroutine了，因此可以实现并发执行。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><ol><li>基本切片</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">s = slice(<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="keyword">print</span> a[s] <span class="comment"># [2  4  6]</span></span><br><span class="line"><span class="keyword">print</span> a[<span class="number">2</span>:<span class="number">7</span>:<span class="number">2</span>] <span class="comment"># [2 4 6]</span></span><br></pre></td></tr></table></figure><ol><li>冒号分隔的切片</li></ol><p>基本语法： <code>ndarrayObj[start:end:step, other dims]</code></p><ul><li>start: 开始切片的序号，默认0</li><li>end: 结束切片的序号, 默认为该维度最后一个</li><li>step: 步长，如果是负数表示从end到start方向进行遍历，默认为1</li></ul><p><code>...</code> : 来使选择元组的长度与数组的维度相同</p><p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'我们的数组是：'</span>  </span><br><span class="line"><span class="keyword">print</span> a</span><br><span class="line"><span class="keyword">print</span>  <span class="string">'\n'</span>  </span><br><span class="line"><span class="comment"># 这会返回第二列元素的数组：  </span></span><br><span class="line"><span class="keyword">print</span>  <span class="string">'第二列的元素是：'</span>  </span><br><span class="line"><span class="keyword">print</span> a[...,<span class="number">1</span>]  </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'\n'</span>  </span><br><span class="line"><span class="comment"># 现在我们从第二行切片所有元素：  </span></span><br><span class="line"><span class="keyword">print</span>  <span class="string">'第二行的元素是：'</span>  </span><br><span class="line"><span class="keyword">print</span> a[<span class="number">1</span>,...]  </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'\n'</span>  </span><br><span class="line"><span class="comment"># 现在我们从第二列向后切片所有元素：</span></span><br><span class="line"><span class="keyword">print</span>  <span class="string">'第二列及其剩余元素是：'</span>  </span><br><span class="line"><span class="keyword">print</span> a[...,<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">#output </span></span><br><span class="line"></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">第二列的元素是：</span><br><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">第二行的元素是：</span><br><span class="line">[<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">第二列及其剩余元素是：</span><br><span class="line">[[<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="整数索引"><a href="#整数索引" class="headerlink" title="整数索引"></a>整数索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arange(<span class="number">1</span>,<span class="number">7</span>)</span><br><span class="line">x = x.reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">y = x[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">print(y) </span><br><span class="line"></span><br><span class="line"><span class="comment"># output :</span></span><br><span class="line"><span class="comment"># [1  4  5]</span></span><br></pre></td></tr></table></figure><p>该结果包括数组中(0,0)，(1,1)和(2,0)位置处的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">x = np.arange(<span class="number">12</span>)</span><br><span class="line">x.resize(<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span>  <span class="string">'我们的数组是：'</span>  </span><br><span class="line"><span class="keyword">print</span> x </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'\n'</span> </span><br><span class="line">rows = np.array([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">3</span>]])</span><br><span class="line">cols = np.array([[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]])</span><br><span class="line">y = x[rows,cols]  </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'这个数组的每个角处的元素是：'</span>  </span><br><span class="line"><span class="keyword">print</span> y</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line">我们的数组是：                                                                 </span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]                                                                   </span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]                                                                   </span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]                                                                   </span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line">这个数组的每个角处的元素是：                                      </span><br><span class="line">[[ <span class="number">0</span>  <span class="number">2</span>]                                                                      </span><br><span class="line"> [ <span class="number">9</span> <span class="number">11</span>]]</span><br></pre></td></tr></table></figure><h3 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h3><p>当结果对象是布尔运算(例如比较运算符)的结果时，将使用此类型的高级索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">x = np.array([[  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],[  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],[  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],[  <span class="number">9</span>,  <span class="number">10</span>,  <span class="number">11</span>]])  </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'我们的数组是：'</span>  </span><br><span class="line"><span class="keyword">print</span> x </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'\n'</span>  </span><br><span class="line"><span class="comment"># 现在我们会打印出大于 5 的元素  </span></span><br><span class="line"><span class="keyword">print</span>  <span class="string">'大于 5 的元素是：'</span>  </span><br><span class="line"><span class="keyword">print</span> x[x &gt;  <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>] </span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>] </span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>] </span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]] </span><br><span class="line"></span><br><span class="line">大于 <span class="number">5</span> 的元素是：</span><br><span class="line">[ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br></pre></td></tr></table></figure><h2 id="副本和视图"><a href="#副本和视图" class="headerlink" title="副本和视图"></a>副本和视图</h2><p>在执行函数时，其中一些返回输入数组的副本，而另一些返回视图。 当内容物理存储在另一个位置时，称为<code>副本</code>。 另一方面，如果提供了相同内存内容的不同视图，我们将其称为<code>视图</code>。</p><ol><li>无复制</li></ol><p>简单的赋值不会创建对象的副本,相当于C中的指针复制，两个对象拥有相同的地址，对任何一个对象进行操作都会影响到之前的对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">a = np.arange(<span class="number">6</span>)  </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'我们的数组是：'</span>  </span><br><span class="line"><span class="keyword">print</span> a </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'调用 id() 函数：'</span>  </span><br><span class="line"><span class="keyword">print</span> id(a)  </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'a 赋值给 b：'</span> </span><br><span class="line">b = a </span><br><span class="line"><span class="keyword">print</span> b </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'b 拥有相同 id()：'</span>  </span><br><span class="line"><span class="keyword">print</span> id(b)  </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'修改 b 的形状：'</span> </span><br><span class="line">b.shape =  <span class="number">3</span>,<span class="number">2</span>  </span><br><span class="line"><span class="keyword">print</span> b </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'a 的形状也修改了：'</span>  </span><br><span class="line"><span class="keyword">print</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">调用 id() 函数：</span><br><span class="line"><span class="number">139747815479536</span></span><br><span class="line"></span><br><span class="line">a 赋值给 b：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">b 拥有相同 id()：</span><br><span class="line"><span class="number">139747815479536</span></span><br><span class="line"></span><br><span class="line">修改 b 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">a 的形状也修改了：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><ol><li>视图或浅复制</li></ol><p>两个对象拥有相同的存储地址，虽然id()函数得到的不一致，但是使用的是同一个内存空间，但是可以呈现出不同的形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">b = a.view()</span><br><span class="line">print(<span class="string">'id(a):'</span>, id(a))</span><br><span class="line">print(<span class="string">'id(b):'</span>, id(b))</span><br><span class="line">print(<span class="string">'a的形状'</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">'b的形状'</span>)</span><br><span class="line">print(b)</span><br><span class="line">b = b.reshape(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">print(<span class="string">'reshape b 之后'</span>)</span><br><span class="line">print(<span class="string">'a的形状'</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">'b的形状'</span>)</span><br><span class="line">print(b)</span><br><span class="line">b[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">print(<span class="string">'对b[0,0]进行赋值操作'</span>, <span class="string">':b[0,0]=10'</span>)</span><br><span class="line">print(<span class="string">'a的形状'</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">'b的形状'</span>)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"></span><br><span class="line">id(a): <span class="number">1796306611056</span></span><br><span class="line">id(b): <span class="number">1796306500144</span></span><br><span class="line">a的形状</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">b的形状</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">reshape b 之后</span><br><span class="line">a的形状</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">b的形状</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">对b[<span class="number">0</span>,<span class="number">0</span>]进行赋值操作 :b[<span class="number">0</span>,<span class="number">0</span>]=<span class="number">10</span></span><br><span class="line">a的形状</span><br><span class="line">[[<span class="number">10</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]]</span><br><span class="line">b的形状</span><br><span class="line">[[<span class="number">10</span>  <span class="number">1</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><ol><li>深复制</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">a = np.array([[<span class="number">10</span>,<span class="number">10</span>],  [<span class="number">2</span>,<span class="number">3</span>],  [<span class="number">4</span>,<span class="number">5</span>]])  </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'数组 a：'</span>  </span><br><span class="line"><span class="keyword">print</span> a </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'创建 a 的深层副本：'</span> </span><br><span class="line">b = a.copy()  </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'数组 b：'</span>  </span><br><span class="line"><span class="keyword">print</span> b </span><br><span class="line"><span class="comment"># b 与 a 不共享任何内容  </span></span><br><span class="line"><span class="keyword">print</span>  <span class="string">'我们能够写入 b 来写入 a 吗？'</span>  </span><br><span class="line"><span class="keyword">print</span> b <span class="keyword">is</span> a </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'修改 b 的内容：'</span> </span><br><span class="line">b[<span class="number">0</span>,<span class="number">0</span>]  =  <span class="number">100</span>  </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'修改后的数组 b：'</span>  </span><br><span class="line"><span class="keyword">print</span> b </span><br><span class="line"><span class="keyword">print</span>  <span class="string">'a 保持不变：'</span>  </span><br><span class="line"><span class="keyword">print</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"></span><br><span class="line">数组 a：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">创建 a 的深层副本：</span><br><span class="line">数组 b：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">我们能够写入 b 来写入 a 吗？</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">修改 b 的内容：</span><br><span class="line">修改后的数组 b：</span><br><span class="line">[[<span class="number">100</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">a 保持不变：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143208573480558080fa77514407cb23834c78c6c7309000" target="_blank" rel="noopener">廖雪峰的官方网站</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#安装&quot;&gt;安装&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#python-解释器&quot;&gt;python 解释器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ide&quot;&gt;IDE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="python" scheme="http://xraorao.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>java8习惯用语</title>
    <link href="http://xraorao.top/2018/08/09/java8%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD/"/>
    <id>http://xraorao.top/2018/08/09/java8习惯用语/</id>
    <published>2018-08-09T02:02:40.000Z</published>
    <updated>2018-08-09T05:37:02.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-8-习惯用语"><a href="#Java-8-习惯用语" class="headerlink" title="Java 8 习惯用语"></a>Java 8 习惯用语</h1><p>本文介绍了java 8 的常用用法： 2017年 IBM developerWorks 最受欢迎的内容</p><h1 id="Java-中的一种更轻松的函数式编程途径"><a href="#Java-中的一种更轻松的函数式编程途径" class="headerlink" title="Java 中的一种更轻松的函数式编程途径"></a>Java 中的一种更轻松的函数式编程途径</h1><h2 id="命令式格式"><a href="#命令式格式" class="headerlink" title="命令式格式"></a>命令式格式</h2><p>下面代码使用命令式格式寻找数组中的目标元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindNemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; names = </span><br><span class="line">      Arrays.asList(<span class="string">"Dory"</span>, <span class="string">"Gill"</span>, <span class="string">"Bruce"</span>, <span class="string">"Nemo"</span>, <span class="string">"Darla"</span>, <span class="string">"Marlin"</span>, <span class="string">"Jacques"</span>);</span><br><span class="line"> </span><br><span class="line">    findNemo(names);</span><br><span class="line">  &#125;                 </span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findNemo</span><span class="params">(List&lt;String&gt; names)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(String name : names) &#123;</span><br><span class="line">      <span class="keyword">if</span>(name.equals(<span class="string">"Nemo"</span>)) &#123;</span><br><span class="line">        found = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(found)</span><br><span class="line">      System.out.println(<span class="string">"Found Nemo"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      System.out.println(<span class="string">"Sorry, Nemo not found"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="声明式格式"><a href="#声明式格式" class="headerlink" title="声明式格式"></a>声明式格式</h2><p>直接采用集合的contains接口来判断是否存在目标元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findNemo</span><span class="params">(List&lt;String&gt; names)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(names.contains(<span class="string">"Nemo"</span>))</span><br><span class="line">    System.out.println(<span class="string">"Found Nemo"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    System.out.println(<span class="string">"Sorry, Nemo not found"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="函数式格式"><a href="#函数式格式" class="headerlink" title="函数式格式"></a>函数式格式</h2><p>尽管函数式格式的编程始终是声明式的，但简单地使用声明式编程并不等于函数式编程。这是因为函数式编程合并了声明式方法与高阶函数。图 1 直观地展示了命令式、声明式和函数式编程之间的关系。</p><p>图 1. 命令式、声明式和函数式编程的联系</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-java8idioms1/fig1.jpg" alt=""></p><p>该例子实现了统计站点访问次数的功能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.raorao.java.base;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hash 的函数式编程用法，统计网站访问次数.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiong Raorao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018-08-09-10:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapMergeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] websites = <span class="keyword">new</span> String[] &#123;<span class="string">"https://www.baidu.com"</span>, <span class="string">"https://www.baidu.com"</span>,</span><br><span class="line">        <span class="string">"https://www.baidu.com"</span>, <span class="string">"https://www.google.com"</span>, <span class="string">"https://www.google.com"</span>,</span><br><span class="line">        <span class="string">"https://www.sina.com.cn"</span>&#125;;</span><br><span class="line">    Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;String, Integer&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    merge(map1, websites);</span><br><span class="line">    incrementPageVisit(map2, websites);</span><br><span class="line">    map1.forEach((k,v)-&gt; System.out.print(<span class="string">"k= "</span> +k + <span class="string">", v= "</span> + v + <span class="string">"\t"</span>));</span><br><span class="line">    System.out.println();</span><br><span class="line">    map2.forEach((k,v)-&gt; System.out.print(<span class="string">"k= "</span> +k + <span class="string">", v= "</span> + v + <span class="string">"\t"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Map&lt;String, Integer&gt; map, String[] args)</span> </span>&#123;</span><br><span class="line">    Stream.of(args).forEach((e) -&gt; map.merge(e, <span class="number">1</span>, (oldValue, value) -&gt; (oldValue + value)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">incrementPageVisit</span><span class="params">(Map&lt;String, Integer&gt; pageVisits, String[] pages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String page : pages) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!pageVisits.containsKey(page)) &#123;</span><br><span class="line">        pageVisits.put(page, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      pageVisits.put(page, pageVisits.get(page) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>merge 函数中使用了map的merge接口，merge函数有四个参数，前面两个参数分别是要处理的key，初始值（如果键不存在，则赋值1），第三个参数（一个拉姆达表达式）接收 map 中该键对应的值作为其参数，并且将该值作为变量传递给 merge 方法中的第二个参数。（拉姆达表达式第二个参数为统计后的新值，实际上就是递增计数）</p><p>下面看看Map.merge()实现的源码，merge函数直接在Map接口中作为默认函数实现的（java 8 引入了接口的默认函数），其实就是把key的旧值得到，然后加上第二个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">merge</span><span class="params">(K key, V value,</span></span></span><br><span class="line"><span class="function"><span class="params">            BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(remappingFunction);</span><br><span class="line">        Objects.requireNonNull(value);</span><br><span class="line">        V oldValue = get(key);</span><br><span class="line">        V newValue = (oldValue == <span class="keyword">null</span>) ? value :</span><br><span class="line">                   remappingFunction.apply(oldValue, value);</span><br><span class="line">        <span class="keyword">if</span>(newValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            remove(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            put(key, newValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="函数组合与集合管道模式"><a href="#函数组合与集合管道模式" class="headerlink" title="函数组合与集合管道模式"></a>函数组合与集合管道模式</h2><p>利用java 8 stream的特性，实现集合的自定义遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> agiledeveloper;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String make;</span><br><span class="line">  <span class="keyword">private</span> String model;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> year;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String theMake, String theModel, <span class="keyword">int</span> yearOfMake)</span> </span>&#123;</span><br><span class="line">    make = theMake;</span><br><span class="line">    model = theModel;</span><br><span class="line">    year = yearOfMake;</span><br><span class="line">  &#125;                   </span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getMake</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> make; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> model; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> year; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iterating</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Car&gt; <span class="title">createCars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">      <span class="keyword">new</span> Car(<span class="string">"Jeep"</span>, <span class="string">"Wrangler"</span>, <span class="number">2011</span>),</span><br><span class="line">      <span class="keyword">new</span> Car(<span class="string">"Jeep"</span>, <span class="string">"Comanche"</span>, <span class="number">1990</span>),</span><br><span class="line">      <span class="keyword">new</span> Car(<span class="string">"Dodge"</span>, <span class="string">"Avenger"</span>, <span class="number">2010</span>),</span><br><span class="line">      <span class="keyword">new</span> Car(<span class="string">"Buick"</span>, <span class="string">"Cascada"</span>, <span class="number">2016</span>),</span><br><span class="line">      <span class="keyword">new</span> Car(<span class="string">"Ford"</span>, <span class="string">"Focus"</span>, <span class="number">2012</span>),</span><br><span class="line">      <span class="keyword">new</span> Car(<span class="string">"Chevrolet"</span>, <span class="string">"Geo Metro"</span>, <span class="number">1992</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getModelsAfter2000UsingPipeline</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   List&lt;Car&gt; cars)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> </span><br><span class="line">     cars.stream()</span><br><span class="line">         .filter(car -&gt; car.getYear() &gt; <span class="number">2000</span>)</span><br><span class="line">         .sorted(Comparator.comparing(Car::getYear))</span><br><span class="line">         .map(Car::getModel)</span><br><span class="line">         .collect(toList());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ibm.com/developerworks/cn/java/j-java8idioms2/index.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="传统-for-循环的函数式替代方案"><a href="#传统-for-循环的函数式替代方案" class="headerlink" title="传统 for 循环的函数式替代方案"></a>传统 for 循环的函数式替代方案</h2><p>传统的for循环会产生垃圾变量,代码量较大。采用函数式for循环更加简洁</p><p>例子：循环产生多个线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">       .forEach(i -&gt; </span><br><span class="line">         executorService.submit(() -&gt; System.out.println(<span class="string">"Running task "</span> + i)));</span><br></pre></td></tr></table></figure><p>封闭范围（闭区间）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.rangeClosed(<span class="number">0</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>跳过值（等差或者自己实现跳过的方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream.iterate(<span class="number">1</span>, e -&gt; e + <span class="number">3</span>)</span><br><span class="line">  .limit(<span class="number">34</span>)</span><br><span class="line">  .sum()</span><br></pre></td></tr></table></figure><p>逆向迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream.iterate(<span class="number">7</span>, e -&gt; e - <span class="number">1</span>)</span><br><span class="line">     .limit(<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p><a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms3/index.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="提倡有帮助的编码"><a href="#提倡有帮助的编码" class="headerlink" title="提倡有帮助的编码"></a>提倡有帮助的编码</h2><p>使用函数式编码可以让代码更便于理解。下面是找出一个数组中名字长度为4的例子，使用函数式编程非常简洁易懂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"Jack"</span>, <span class="string">"Jill"</span>, <span class="string">"Nate"</span>, <span class="string">"Kara"</span>, <span class="string">"Kim"</span>,<span class="string">"Jullie"</span>, <span class="string">"Paul"</span>, <span class="string">"Peter"</span>);</span><br><span class="line">         </span><br><span class="line">System.out.println(</span><br><span class="line">  names.stream()</span><br><span class="line">    .filter(name -&gt; name.length() == <span class="number">4</span>)</span><br><span class="line">    .collect(Collectors.joining(<span class="string">", "</span>)));</span><br></pre></td></tr></table></figure><h2 id="传递表达式（pass-through-lambdas）的替代方案-使用方法引用"><a href="#传递表达式（pass-through-lambdas）的替代方案-使用方法引用" class="headerlink" title="传递表达式（pass-through lambdas）的替代方案(使用方法引用)"></a>传递表达式（pass-through lambdas）的替代方案(使用方法引用)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">numbers.stream()</span><br><span class="line">  .filter(e -&gt; e % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">  .forEach(e -&gt; System.out.println(e));</span><br></pre></td></tr></table></figure><p>第二行forEach 循环里面对于元素并没有进行实际的操作，只是传入了元素的值，因此在这种情况下可以采用元素的方法引用来代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers.stream()</span><br><span class="line">  .filter(e -&gt; e % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">  .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><a href="http://www.ibm.com/developerworks/cn/java/j-java8idioms4/index.html" target="_blank" rel="noopener">参考链接</a></p><h3 id="实例方法的实参传递"><a href="#实例方法的实参传递" class="headerlink" title="实例方法的实参传递"></a>实例方法的实参传递</h3><p><img src="https://www.ibm.com/developerworks/cn/java/j-java8idioms5/figure1.jpg" alt=""></p><p>我们使用以下格式将此 lambda 表达式替换为方法引用 System.out::println：referenceToInstance::methodName。</p><p>例如传递一个this上面的实参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stream</span><br><span class="line">.map(e -&gt; increment(e)) </span><br><span class="line">.map(e -&gt; <span class="keyword">this</span>.increment(e))</span><br><span class="line">.map(<span class="keyword">this</span>::increment)</span><br></pre></td></tr></table></figure><h3 id="静态方法的实参传递"><a href="#静态方法的实参传递" class="headerlink" title="静态方法的实参传递"></a>静态方法的实参传递</h3><p>ClassName::staticMethodName</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.map(Integer::valueOf)</span><br></pre></td></tr></table></figure><h3 id="将形参传递给目标"><a href="#将形参传递给目标" class="headerlink" title="将形参传递给目标"></a>将形参传递给目标</h3><p><img src="https://www.ibm.com/developerworks/cn/java/j-java8idioms5/figure2.jpg" alt=""></p><p>这个和上面的静态方法的实参传格式是一样的，但是这里是将<strong>形参作为实例方法的调用目标</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.map(e -&gt; e.doubleValue())</span><br></pre></td></tr></table></figure><p>在这个示例中，形参 e（我们假设其推断类型为 Integer）是对 doubleValue 方法的调用的目标。上图中给出了这种传递 lambda 表达式的结构。</p><h3 id="传递构造函数调用"><a href="#传递构造函数调用" class="headerlink" title="传递构造函数调用"></a>传递构造函数调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.collect(toCollection(() -&gt; <span class="keyword">new</span> LinkedList&lt;Double&gt;()));</span><br></pre></td></tr></table></figure><p>代码的目的是获取一个数据 Stream ，将它精减或收集到一个 LinkedList 中。toCollection 方法接受一个 Supplier 作为其实参。Supplier 不接受任何形参，因此 () 为空。它返回一个 Collection 实例，该实例在本例中是 LinkedList。</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-java8idioms5/figure3.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.collect(toCollection(LinkedList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure><h3 id="传递多个实参"><a href="#传递多个实参" class="headerlink" title="传递多个实参"></a>传递多个实参</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.reduce(<span class="number">0</span>, (total, e) -&gt; Integer.sum(total, e)));</span><br></pre></td></tr></table></figure><p><img src="https://www.ibm.com/developerworks/cn/java/j-java8idioms5/figure4.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.reduce(<span class="number">0</span>, Integer::sum));</span><br></pre></td></tr></table></figure><p><a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms5/index.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="为什么完美的-lambda-表达式只有一行"><a href="#为什么完美的-lambda-表达式只有一行" class="headerlink" title="为什么完美的 lambda 表达式只有一行"></a>为什么完美的 lambda 表达式只有一行</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms6/index.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><p>Thread 类的构造函数想要一个实现 Runnable 的实例。在本例中，我们传递了一个 lambda 表达式，而不是传递一个对象。我们可以选择向各种各样的方法和构造函数传递 lambda 表达式，包括在 Java 8 之前创建的一些方法和构造函数。这很有效，因为 lambda 表达式在 Java 中表示为函数接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"In another thread"</span>));</span><br></pre></td></tr></table></figure><p>函数接口有 3 条重要法则：</p><p>一个函数接口只有一个抽象方法。<br>在 Object 类中属于公共方法的抽象方法不会被视为单一抽象方法。<br>函数接口可以有默认方法和静态方法。</p><p><strong>任何满足单一抽象方法法则的接口，都会被自动视为函数接口。这包括 Runnable 和 Callable 等传统接口，以及您自己构建的自定义接口。</strong></p><h3 id="内置函数接口"><a href="#内置函数接口" class="headerlink" title="内置函数接口"></a>内置函数接口</h3><p>除了已经提到的单一抽象方法之外，JDK 8 还包含多个新函数接口。最常用的接口包括 Function<t, r="">、Predicate<t> 和 Consumer<t>，它们是在 java.util.function 包中定义的。Stream 的 map 方法接受 Function<t, r=""> 作为参数。类似地，filter 使用 Predicate<t>，forEach 使用 Consumer<t>。该包还有其他函数接口，比如 Supplier<t>、BiConsumer<t, u=""> 和 BiFunction<t, u,="" r="">。</t,></t,></t></t></t></t,></t></t></t,></p><p>可以将内置函数接口用作我们自己的方法的参数。例如，假设我们有一个 Device 类，它包含方法 checkout 和 checkin 来指示是否正在使用某个设备。当用户请求一个新设备时，方法 getFromAvailable 从可用设备池中返回一个设备，或在必要时创建一个新设备。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">borrowDevice</span><span class="params">(Consumer&lt;Device&gt; use)</span> </span>&#123;</span><br><span class="line">  Device device = getFromAvailable();</span><br><span class="line">   </span><br><span class="line">  device.checkout();</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    use.accept(device);      </span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    device.checkin();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>borrowDevice 方法：</p><ul><li>接受 Consumer<device> 作为参数。</device></li><li>从池中获取一个设备（我们在这个示例中不关心线程安全问题）。</li><li>调用 checkout 方法将设备状态设置为 checked out。</li><li>将设备交付给用户。</li></ul><p>在完成设备调用后返回到 Consumer 的 accept 方法时，通过调用 checkin 方法将设备状态更改为 checked in。</p><p>下面给出了一种使用 borrowDevice 方法的方式：</p><p>new Sample().borrowDevice(device -&gt; System.out.println(“using “ + device));<br>因为该方法接收一个函数接口作为参数，所以传入一个 lambda 表达式作为参数是可以接受的。</p><h3 id="自定义函数接口"><a href="#自定义函数接口" class="headerlink" title="自定义函数接口"></a>自定义函数接口</h3><p>尽管最好尽量使用内置函数接口，但有时需要自定义函数接口。</p><p>要创建自己的函数接口，需要做两件事：</p><p>使用 @FunctionalInterface 注释该接口，这是 Java 8 对自定义函数接口的约定。<br>确保该接口只有一个抽象方法。<br>该约定清楚地表明该接口应接收 lambda 表达式。当编译器看到该注释时，它会验证该接口是否只有一个抽象方法。</p><p>使用 @FunctionalInterface 注释可以确保，如果在未来更改该接口时意外违反抽象方法数量规则，您会获得错误消息。这很有用，因为您会立即发现问题，而不是留给另一位开发人员在以后处理它。没有人希望在将 lambda 表达式传递给其他人的自定义接口时获得错误消息。</p><h3 id="创建自定义函数接口"><a href="#创建自定义函数接口" class="headerlink" title="创建自定义函数接口"></a>创建自定义函数接口</h3><p>作为一个示例，我们将创建一个 Order 类，它有一系列 OrderItem 以及一个转换并输出它们的方法。我们首先创建一个接口。</p><p>下面的代码将创建一个 Transformer 函数接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transformer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">transform</span><span class="params">(T input)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口用 @FunctionalInterface 注释做了标记，表明它是一个函数接口。因为该注释包含在 java.lang 包中，所以没有必要导入。该接口有一个名为 transform 的方法，后者接受一个参数化为 T 类型的对象，并返回一个相同类型的转换后对象。转换的语义将由该接口的实现来决定。</p><p>这是 OrderItem 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderItem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> price;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrderItem</span><span class="params">(<span class="keyword">int</span> theId, <span class="keyword">int</span> thePrice)</span> </span>&#123;</span><br><span class="line">    id = theId;</span><br><span class="line">    price = thePrice;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> price; &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> String.format(<span class="string">"id: %d price: %d"</span>, id, price); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderItem 是一个简单的类，它有两个属性：id 和 price，以及一个 toString 方法。</p><p>现在来看看 Order 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  List&lt;OrderItem&gt; items;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(List&lt;OrderItem&gt; orderItems)</span> </span>&#123;</span><br><span class="line">    items = orderItems;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transformAndPrint</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Transformer&lt;Stream&lt;OrderItem&gt;&gt; transformOrderItems)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    transformOrderItems.transform(items.stream())</span><br><span class="line">      .forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>transformAndPrint 方法接受 Transform<stream<orderitem> 作为参数，调用 transform 方法来转换属于 Order 实例的订单项，然后按转换后的顺序输出这些订单项。</stream<orderitem></p><p>这是一个使用该方法的样本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.comparing;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;     </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order(Arrays.asList(</span><br><span class="line">      <span class="keyword">new</span> OrderItem(<span class="number">1</span>, <span class="number">1225</span>),</span><br><span class="line">      <span class="keyword">new</span> OrderItem(<span class="number">2</span>, <span class="number">983</span>),</span><br><span class="line">      <span class="keyword">new</span> OrderItem(<span class="number">3</span>, <span class="number">1554</span>)</span><br><span class="line">    ));</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    order.transformAndPrint(<span class="keyword">new</span> Transformer&lt;Stream&lt;OrderItem&gt;&gt;() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Stream&lt;OrderItem&gt; <span class="title">transform</span><span class="params">(Stream&lt;OrderItem&gt; orderItems)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderItems.sorted(comparing(OrderItem::getPrice));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们传递一个匿名内部类作为 transformAndPrint 方法的参数。在 transform 方法内，调用给定流的 sorted 方法，这会对订单项进行排序。这是我们的代码的输出，其中显示了按价格升序排列的订单项：</p><p>id: 2 price: 983<br>id: 1 price: 1225<br>id: 3 price: 1554<br>lambda 表达式的强大功能<br>在任何需要函数接口的地方，我们都有 3 种选择：</p><p>传递一个匿名内部类。<br>传递一个 lambda 表达式。<br>在某些情况下传递一个方法引用而不是 lambda 表达式。<br>传递匿名内部类的过程很复杂，我们只能传递方法引用来替代直通 lambda 表达式。考虑如果我们重写对 transformAndPrint 函数的调用，以使用 lambda 表达式来代替匿名内部类，将会发生什么：</p><p>order.transformAndPrint(orderItems -&gt; orderItems.sorted(comparing(OrderItem::getPrice)));<br>与我们最初提供的匿名内部类相比，这简洁得多且更容易阅读。</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms7/index.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="Java-知道您的类型"><a href="#Java-知道您的类型" class="headerlink" title="Java 知道您的类型"></a>Java 知道您的类型</h2><p>java 类型推断</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms8/index.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="级联-lambda-表达式"><a href="#级联-lambda-表达式" class="headerlink" title="级联 lambda 表达式"></a>级联 lambda 表达式</h2><p>类似建造者模式一样，处理完对象然后返回出来</p><p>首先，考虑区分高阶函数与常规函数的规则：</p><ul><li>常规函数</li></ul><p>可以接收对象<br>可以创建对象<br>可以返回对象</p><ul><li>高阶函数</li></ul><p>可以接收函数<br>可以创建函数<br>可以返回函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; result1 = numbers1.stream()</span><br><span class="line">  .filter(e -&gt; e &gt; <span class="number">50</span>)</span><br><span class="line">  .collect(toList());</span><br></pre></td></tr></table></figure><p><a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms9/index.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="使用闭包捕获状态"><a href="#使用闭包捕获状态" class="headerlink" title="使用闭包捕获状态"></a>使用闭包捕获状态</h2><p>在 Java™ 编程中，我们以不严格地使用术语 lambda 表达式来表示 lambda 表达式和闭包。但在某些情况下，理解它们的区别很重要。lambda 表达式是无状态的，而闭包是带有状态的。将 lambda 表达式替换为闭包，是一种管理函数式程序中的状态的好方法。</p><p><strong>闭包：是引用了自由变量的函数。这个函数通常被定义在另一个外部函数中，并且引用了外部函数中的变量。</strong></p><p>java 中闭包有多种方式：</p><ol><li>内部类</li><li>.new : 显示创建内部类的实例</li><li>.this : 显式引用外部类的变量</li><li>局部内部类</li><li>匿名内部类</li><li>final 关键字</li></ol><p>闭包的价值：是引用了自由变量的函数。这个函数通常被定义在另一个外部函数中，并且引用了外部函数中的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String location = <span class="string">"World"</span>;</span><br><span class="line">   </span><br><span class="line">  Runnable runnable = () -&gt; System.out.println(<span class="string">"Hello "</span> + location);</span><br><span class="line">   </span><br><span class="line">  runnable.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得益于 lambda 表达式，代码变得更简洁，但 location 的范围和绑定没有更改。lambda 表达式中的变量 location 被绑定到 lambda 表达式的词法范围中的变量 location。严格来讲，此代码中的 lambda 表达式是一个闭包。</p><h3 id="闭包携带状态"><a href="#闭包携带状态" class="headerlink" title="闭包携带状态"></a>闭包携带状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"calling runnable"</span>);</span><br><span class="line">                    </span><br><span class="line">    <span class="comment">//level 2 of stack</span></span><br><span class="line">    runnable.run();</span><br><span class="line">  &#125; </span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">4</span>;  <span class="comment">//level 1 of stack</span></span><br><span class="line">    call(</span><br><span class="line">      () -&gt; System.out.println(value) <span class="comment">//level 3 of stack</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码中的闭包使用了来自它的词法范围的变量 value。如果 main 是在堆栈级别 1 上执行的，那么 call 方法的主体会在堆栈级别 2 上执行。因为 Runnable 的 run 方法是从 call 内调用的，所以该闭包的主体会在级别 3 上运行。如果 call 方法要将该闭包传递给另一个方法（进而推迟调用的位置），则执行的堆栈级别可能高于 3。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-8-习惯用语&quot;&gt;&lt;a href=&quot;#Java-8-习惯用语&quot; class=&quot;headerlink&quot; title=&quot;Java 8 习惯用语&quot;&gt;&lt;/a&gt;Java 8 习惯用语&lt;/h1&gt;&lt;p&gt;本文介绍了java 8 的常用用法： 2017年 IBM devel
      
    
    </summary>
    
      <category term="编程" scheme="http://xraorao.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="java" scheme="http://xraorao.top/categories/%E7%BC%96%E7%A8%8B/java/"/>
    
    
      <category term="java" scheme="http://xraorao.top/tags/java/"/>
    
      <category term="编程" scheme="http://xraorao.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java正则表达式</title>
    <link href="http://xraorao.top/2018/07/20/java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://xraorao.top/2018/07/20/java正则表达式/</id>
    <published>2018-07-20T07:18:51.000Z</published>
    <updated>2018-07-20T09:16:41.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>处理字符串时，有很多较为复杂的字符串用普通的字符串处理函数无法干净的完成。比如说，可能需要验证一个Email地址是否合法，为此需要查看许多不容易检查的规则。这正是正则表达式的用武之地。正则表达式是功能强大而简明的字符组，其中可以包含大量的逻辑，特别值得一提的是正则表达式相当简短。</p><p>正则表达式定义了字符串的模式。<br>正则表达式可以用来搜索、编辑或处理文本。<br>正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。</p><h1 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h1><div class="table-container"><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符。序列”\\\\”匹配”\\”，”\(“匹配”(“。</td></tr><tr><td>^</td><td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配。</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td></tr><tr><td>*</td><td>匹配前面的子表达式任意次。例如，zo<em>能匹配“z”，“zo”以及“zoo”。</em>等价于{0,}。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td></tr><tr><td>\?</td><td><strong>匹配前面的子表达式零次或一次。</strong> 例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</td></tr><tr><td>{n}</td><td>n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td></tr><tr><td>{n,}</td><td><strong>n是一个非负整数。至少匹配n次。</strong> 例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td></tr><tr><td>{n,m}</td><td>m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td>\?</td><td>当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是<code>非贪婪</code>的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的<code>贪婪模式</code>则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。</td></tr><tr><td>.点</td><td>匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。</td></tr><tr><td>(pattern)</td><td><strong>匹配pattern并获取这一匹配。</strong> 所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用”(“或者”)“。</td></tr><tr><td>(?:pattern)</td><td><strong>匹配pattern但不获取匹配结果，</strong> 也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(\竖线)”来组合一个模式的各个部分是很有用。例如“industr(?:y\竖线ies)”就是一个比“industry\竖线industries”更简略的表达式。</td></tr><tr><td>(?=pattern)</td><td><strong>正向肯定预查，</strong> 在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95\竖线98\竖线NT\竖线2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?!pattern)</td><td><strong>正向否定预查，</strong> 在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95\竖线98\竖线NT\竖线2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。</td></tr><tr><td>(?&lt;=pattern)</td><td>反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95\竖线98\竖线NT\竖线2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</td></tr><tr><td>(?&lt;!pattern)</td><td>反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95\竖线98\竖线NT\竖线2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。</td></tr><tr><td>x\竖线y</td><td><strong>匹配x或y。</strong> 例如，“z\竖线food”能匹配“z”或“food”或”zood”(此处请谨慎)。“(z\竖线f)ood”则匹配“zood”或“food”。</td></tr><tr><td>[xyz]</td><td>字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。</td></tr><tr><td><sup><a href="#fn_xyz" id="reffn_xyz">xyz</a></sup></td><td>负值字符集合。匹配未包含的任意字符。例如，“<sup><a href="#fn_abc" id="reffn_abc">abc</a></sup>”可以匹配“plain”中的“plin”。</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身.</td></tr><tr><td><sup><a href="#fn_a-z" id="reffn_a-z">a-z</a></sup></td><td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，“<sup><a href="#fn_a-z" id="reffn_a-z">a-z</a></sup>”可以匹配任何不在“a”到“z”范围内的任意字符。</td></tr><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。</td></tr><tr><td>\B</td><td>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</td></tr><tr><td>\cx</td><td>匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。</td></tr><tr><td>\d</td><td>匹配一个数字字符。等价于[0-9]。</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于<sup><a href="#fn_0-9" id="reffn_0-9">0-9</a></sup>。</td></tr><tr><td>\f</td><td>匹配一个换页符。等价于\x0c和\cL。</td></tr><tr><td>\n</td><td>匹配一个换行符。等价于\x0a和\cJ。</td></tr><tr><td>\r</td><td>匹配一个回车符。等价于\x0d和\cM。</td></tr><tr><td>\s</td><td>匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td></tr><tr><td>\S</td><td>匹配任何可见字符。等价于<sup><a href="#fn_ \f\n\r\t\v" id="reffn_ \f\n\r\t\v"> \f\n\r\t\v</a></sup>。</td></tr><tr><td>\t</td><td>匹配一个制表符。等价于\x09和\cI。</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。等价于\x0b和\cK。</td></tr><tr><td>\w</td><td>匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的”单词”字符使用Unicode字符集。</td></tr><tr><td>\W</td><td>匹配任何非单词字符。等价于“<sup><a href="#fn_A-Za-z0-9_" id="reffn_A-Za-z0-9_">A-Za-z0-9_</a></sup>”。</td></tr><tr><td>\xn</td><td>匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。</td></tr><tr><td>\num</td><td>匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。</td></tr><tr><td>\n</td><td>标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。</td></tr><tr><td>\nm</td><td>标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。</td></tr><tr><td>\nml</td><td>如果n为八进制数字（0-7），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。</td></tr><tr><td>\un</td><td>匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（&copy;）。</td></tr><tr><td>\\&lt; \></td><td>匹配词（word）的开始（\&lt;）和结束（>）。例如正则表达式\<the\>能够匹配字符串”for the wise”中的”the”，但是不能匹配字符串”otherwise”中的”the”。注意：这个元字符不是所有的软件都支持的。</the\></td></tr><tr><td>\( \)</td><td>将 \( 和 \) 之间的表达式定义为“组”（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 \1 到\9 的符号来引用。</td></tr><tr><td> \竖线</td><td>将两个匹配条件进行逻辑“或”（Or）运算。例如正则表达式(him\竖线her) 匹配”it belongs to him”和”it belongs to her”，但是不能匹配”it belongs to them.”。注意：这个元字符不是所有的软件都支持的。</td></tr><tr><td>+</td><td>匹配1或多个正好在它之前的那个字符。例如正则表达式9+匹配9、99、999等。注意：这个元字符不是所有的软件都支持的。</td></tr><tr><td>?</td><td>匹配0或1个正好在它之前的那个字符。注意：这个元字符不是所有的软件都支持的。</td></tr><tr><td>{i} {i,j}</td><td>匹配指定数目的字符，这些字符是在它之前的表达式定义的。例如正则表达式A[0-9]{3} 能够匹配字符”A”后面跟着正好3个数字字符的串，例如A123、A348等，但是不匹配A1234。而正则表达式[0-9]{4,6} 匹配连续的任意4个、5个或者6个数字</td></tr></tbody></table></div><h1 id="java使用方法"><a href="#java使用方法" class="headerlink" title="java使用方法"></a>java使用方法</h1><p>String 类有三个基本操作使用正则：</p><p>匹配： matches()<br>切割： split()<br>替换： replaceAll()  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以空格分割</span></span><br><span class="line">String str1 = <span class="string">"1 2 3          4 54       5 6"</span>;</span><br><span class="line">String[] numbers = str1.split(<span class="string">" +"</span>);</span><br><span class="line"><span class="keyword">for</span> (String temp : numbers) &#123;</span><br><span class="line">    System.out.println(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换，替换所有的数字为*</span></span><br><span class="line">String str2 = <span class="string">"abd123:adad46587:asdadasadsfgi#%^^9090"</span>;</span><br><span class="line">System.out.println(str2.replaceAll(<span class="string">"[0-9]"</span>, <span class="string">"*"</span>));</span><br><span class="line">System.out.println(str2.replaceAll(<span class="string">"\\d"</span>, <span class="string">"*"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配匹配邮箱</span></span><br><span class="line">String mail1 = <span class="string">"ababc@asa.com"</span>;</span><br><span class="line">String mail2 = <span class="string">"ababc@asa.com.cn"</span>;</span><br><span class="line">String mail3 = <span class="string">"ababc@asa"</span>;</span><br><span class="line"><span class="comment">//        String mainRegex = "[0-9a-zA-Z_]+@[0-9a-zA-Z_]++(\\.[0-9a-zA-Z_]+&#123;2,4&#125;)+";</span></span><br><span class="line">String mainRegex = <span class="string">"\\w+@\\w+(\\.\\w&#123;2,4&#125;)+"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(mail1.matches(mainRegex));<span class="comment">//true</span></span><br><span class="line">System.out.println(mail2.matches(mainRegex));<span class="comment">//true</span></span><br><span class="line">System.out.println(mail3.matches(mainRegex));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">java中正则匹配的对象：</span><br><span class="line">pattern:</span><br><span class="line">　　Pattern 　　Pattern.complie(regexString)</span><br><span class="line">　　Macther 　　Pattern.matches(regexString)</span><br><span class="line">Matcher：</span><br><span class="line">　　<span class="keyword">boolean</span> 　  matcher.find() <span class="comment">//查找下一个匹配对象</span></span><br><span class="line">　　String 　　 matcher.guorp() <span class="comment">//返回整个匹配模式匹配到的结果</span></span><br><span class="line">　　<span class="keyword">boolean</span> 　  matcher.matches() <span class="comment">//尝试将整个区域与模式匹配</span></span><br><span class="line">　　  <span class="keyword">int</span> 　　　　matcher.groupCount() <span class="comment">//返回匹配规则的分组，如：(aa)(bb)：这表示两组</span></span><br><span class="line">　　String        matcher.group(<span class="keyword">int</span> group)<span class="comment">//返回匹配对象对应分组的匹配结果</span></span><br><span class="line">　　MatcheResult  matcher.toMatchResult()<span class="comment">//将匹配结果一MatchResult的形式返回</span></span><br></pre></td></tr></table></figure><h2 id="场景一：仅仅使用Matcher对象来匹配想要的字符串"><a href="#场景一：仅仅使用Matcher对象来匹配想要的字符串" class="headerlink" title="场景一：仅仅使用Matcher对象来匹配想要的字符串"></a>场景一：仅仅使用Matcher对象来匹配想要的字符串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配出3个字符的字符串</span></span><br><span class="line">String str = <span class="string">"abc 124 ewqeq qeqe   qeqe   qeqe  aaaa  fs fsdfs d    sf sf sf  sf sfada dss dee ad a f s f sa a'lfsd;'l"</span>;</span><br><span class="line">Pattern pt = Pattern.compile(<span class="string">"\\b\\w&#123;3&#125;\\b"</span>);</span><br><span class="line">Matcher match = pt.matcher(str);</span><br><span class="line"><span class="keyword">while</span> (match.find()) &#123;</span><br><span class="line">    System.out.println(match.group());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匹配出邮箱地址</span></span><br><span class="line">String str2 = <span class="string">"dadaadad   da da   dasK[PWEOO-123- DASJAD@DHSJK.COM DADA@DAD.CN =0KFPOS9IR23J0IS ADHAJ@565@ADA.COM.CN shuqi@162.com UFSFJSFI-SI- "</span>;</span><br><span class="line">Pattern pet2 = Pattern.compile(<span class="string">"\\b\\w+@\\w+(\\.\\w&#123;2,4&#125;)+\\b"</span>);</span><br><span class="line">Matcher match2 = pet2.matcher(str2);</span><br><span class="line"><span class="keyword">while</span> (match2.find()) &#123;</span><br><span class="line">    System.out.println(match2.group());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="场景二：匹配规则中包含匹配组，要求匹配得到相应的匹配组的数据"><a href="#场景二：匹配规则中包含匹配组，要求匹配得到相应的匹配组的数据" class="headerlink" title="场景二：匹配规则中包含匹配组，要求匹配得到相应的匹配组的数据"></a>场景二：匹配规则中包含匹配组，要求匹配得到相应的匹配组的数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String sr = <span class="string">"dada ada adad adsda ad asdda adr3 fas daf fas fdsf 234 adda"</span>;</span><br><span class="line"><span class="comment">//包含两个匹配组，一个是三个字符，一个是匹配四个字符</span></span><br><span class="line">Pattern pet = Pattern.compile(<span class="string">"\\b(\\w&#123;3&#125;) *(\\w&#123;4&#125;)\\b"</span>);</span><br><span class="line">Matcher match = pet.matcher(sr);</span><br><span class="line"><span class="keyword">int</span> countAll = match.groupCount();<span class="comment">//2 </span></span><br><span class="line"><span class="keyword">while</span> (match.find()) &#123;</span><br><span class="line">    System.out.print(<span class="string">"匹配组结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countAll; i++) &#123;</span><br><span class="line">        System.out.print(String.format(<span class="string">"\n\t第%s组的结果是:%s"</span>,i+<span class="number">1</span>,match.group(i + <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(<span class="string">"\n匹配的整个结果:"</span>);</span><br><span class="line">    System.out.println(match.group());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="场景三：将每次得到的结果使用MatcheResult保存"><a href="#场景三：将每次得到的结果使用MatcheResult保存" class="headerlink" title="场景三：将每次得到的结果使用MatcheResult保存"></a>场景三：将每次得到的结果使用MatcheResult保存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String sr = <span class="string">"dada ada adad adsda ad asdda adr3 fas daf fas fdsf 234 adda"</span>;</span><br><span class="line">Pattern pet = Pattern.compile(<span class="string">"\\b(\\w&#123;3&#125;) *(\\w&#123;4&#125;)\\b"</span>);</span><br><span class="line">Matcher match = pet.matcher(sr);</span><br><span class="line">MatchResult ms = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (match.find()) &#123;</span><br><span class="line">    ms = match.toMatchResult();</span><br><span class="line">    System.out.print(<span class="string">"匹配对象的组结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ms.groupCount(); i++) &#123;</span><br><span class="line">        System.out.print(String.format(<span class="string">"\n\t第%s组的结果是:%s"</span>,i+<span class="number">1</span>,ms.group(i + <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(<span class="string">"\n匹配的整个结果:"</span>);</span><br><span class="line">    System.out.println(ms.group());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文档：</p><ul><li><a href="https://www.cnblogs.com/shuqi/p/4427693.html" target="_blank" rel="noopener">java正则表达式示例</a></li><li><a href="https://www.cnblogs.com/lzq198754/p/5780340.html" target="_blank" rel="noopener">Java正则表达式的语法与示例</a></li><li><a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">Java正则表达式</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;p&gt;处理字符串时，有很多较为复杂的字符串用普通的字符串处理函数无法干净的完成。比如说，可能需要验证一个Email地址是否
      
    
    </summary>
    
      <category term="笔记" scheme="http://xraorao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://xraorao.top/categories/%E7%AC%94%E8%AE%B0/java/"/>
    
    
      <category term="笔记" scheme="http://xraorao.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://xraorao.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java锁和监视器</title>
    <link href="http://xraorao.top/2018/07/16/java%E9%94%81%E5%92%8C%E7%9B%91%E8%A7%86%E5%99%A8/"/>
    <id>http://xraorao.top/2018/07/16/java锁和监视器/</id>
    <published>2018-07-16T11:34:40.000Z</published>
    <updated>2018-12-11T02:21:20.148Z</updated>
    
    <content type="html"><![CDATA[<p>在JVM的规范中，有这么一些话：  “在JVM中，每个对象和类在逻辑上都是和一个监视器相关联的，为了实现监视器的排他性监视能力，JVM为每一个对象和类都关联一个锁（内置锁），锁住了一个对象，就是获得对象相关联的监视器” </p><p><strong>锁为监视器的实现提供了必要的支持。</strong></p><p>java 提供了synchronized关键字来支持内置锁。synchronized 关键字可以放在方法的前面、对象的前面、类的前面。</p><h1 id="同步方法中的锁"><a href="#同步方法中的锁" class="headerlink" title="同步方法中的锁"></a>同步方法中的锁</h1><p>当线程调用同步方法时，它自动获得这个方法所在对象的内在锁，并且方法返回时释放锁，如果发生未捕获的异常，也会释放锁。</p><p>当调用静态同步方法时，因为静态方法和类相关联，线程获得和这个类关联的Class对象的内在锁。<br>使用内在锁后，把deposit方法和withdraw方法修改为同步方法，就可以避免线程干扰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">balance = balance + amount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">balance = balance - amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="同步语句"><a href="#同步语句" class="headerlink" title="同步语句"></a>同步语句</h1><p>同步语句必须指定提供内在锁的对象，其基本用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>（提供锁的对象）&#123;</span><br><span class="line">临界代码</span><br><span class="line">&#125;</span><br><span class="line">用同步语句修改BankAccount类中的方法如下：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">balance = balance + amount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">balance = balance - amount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="同步类"><a href="#同步类" class="headerlink" title="同步类"></a>同步类</h1><p>把synchronized关键字放在类的前面，这个类中的所有方法都是同步方法。</p><h1 id="可重入同步"><a href="#可重入同步" class="headerlink" title="可重入同步"></a>可重入同步</h1><p>线程可以获得他已经拥有的锁，运行线程多次获得同一个锁，就是可以重入（reentrant）同步。这种情况通常是同步代码直接或者间接的调用也包含了同步代码的方法，并且两个代码集都使用同一个锁。如果没有可重入同步，那么，同步代码就必须采取很多额外的预防措施避免线程阻塞自己。java java.util.concurrent 包中的  ReentrantLock 即为可重入锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Lock bankLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">…</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalBalance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      bankLock.lock();</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">double</span> a : accounts)</span><br><span class="line">            sum += a;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> sum;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span></span><br><span class="line">      &#123;</span><br><span class="line">         bankLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="Lock-和-synchronized-的选择"><a href="#Lock-和-synchronized-的选择" class="headerlink" title="Lock 和 synchronized 的选择"></a>Lock 和 synchronized 的选择</h1><ul><li>Lock是一个接口，而synchronized是java的关键字，synchronized是内置的语言实现</li><li>synchronized在发生异常的时候，会自动释放锁，不会发生死锁，而Lock在发生异常的时候，如果没有主动的去释放锁（unlock)，则会造成死锁的现象，因此Lock需要用try-catch-finally，在块中释放锁</li><li>Lock可以让等待锁的线程响应中断(tryLock(time))，synchronized不行，使用synchronized锁的线程会一直等待下去，不能响应中断。</li><li>通过Lock可以知道有没有成功获取锁，但是synchronized无法办到</li><li>Lock可以提高多个线程进行读操作的效率</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/keeplearnning/p/7020287.html" target="_blank" rel="noopener">锁和监视器之间的区别 – Java并发</a></li><li><a href="https://blog.csdn.net/fujunsfzh/article/details/53517536" target="_blank" rel="noopener">java 内在锁（intrinsic lock）或者监视器锁（monitor lock）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在JVM的规范中，有这么一些话：  “在JVM中，每个对象和类在逻辑上都是和一个监视器相关联的，为了实现监视器的排他性监视能力，JVM为每一个对象和类都关联一个锁（内置锁），锁住了一个对象，就是获得对象相关联的监视器” &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁为监视器的实现提供了
      
    
    </summary>
    
      <category term="笔记" scheme="http://xraorao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://xraorao.top/categories/%E7%AC%94%E8%AE%B0/java/"/>
    
    
      <category term="笔记" scheme="http://xraorao.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://xraorao.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java面试常考</title>
    <link href="http://xraorao.top/2018/07/15/java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/"/>
    <id>http://xraorao.top/2018/07/15/java面试常考/</id>
    <published>2018-07-15T02:22:53.000Z</published>
    <updated>2018-12-07T08:47:42.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><h2 id="方法重载和方法重写"><a href="#方法重载和方法重写" class="headerlink" title="方法重载和方法重写"></a>方法重载和方法重写</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/7b2152a85b9a4ebab6dfda7e995a8491" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/7b2152a85b9a4ebab6dfda7e995a8491</a><br>来源：牛客网</p><p><strong>方法重载发生在编译器，方法重写发生在运行期。</strong></p><p><strong>方法重写的原则：</strong></p><ul><li>重写方法的方法名称、参数列表必须与原方法的相同，返回类型可以相同也可以是原类型的子类型(从Java SE5开始支持)。</li><li>重写方法不能比原方法访问性差（即访问权限不允许缩小）。</li><li>重写方法不能比原方法抛出更多的异常。</li><li>被重写的方法不能是final类型，因为final修饰的方法是无法重写的。</li><li>被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写。</li><li>被重写的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足重写条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足重写条件，但是仍然不会发生重写，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。</li><li>重写是发生在运行时的，因为编译期编译器不知道并且没办法确定该去调用哪个方法，JVM会在代码运行的时候作出决定。</li></ul><p><strong>方法重载的原则：</strong></p><ul><li>方法名称必须相同。</li><li>参数列表必须不同（个数不同、或类型不同、参数类型排列顺序不同等）。</li><li>方法的返回类型可以相同也可以不相同。</li><li>仅仅返回类型不同不足以成为方法的重载。</li><li>重载是发生在编译时的，因为编译器可以根据参数的类型来选择使用哪个方法。</li></ul><p><strong> 重写和重载的不同：</strong></p><ul><li>方法重写要求参数列表必须一致，而方法重载要求参数列表必须不一致。</li><li>方法重写要求返回类型必须一致(或为其子类型)，方法重载对此没有要求。</li><li>方法重写只能用于子类重写父类的方法，方法重载用于同一个类中的所有方法。</li><li>方法重写对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。</li><li>父类的一个方法只能被子类重写一次，而一个方法可以在所有的类中可以被重载多次。</li><li>重载是编译时多态，重写是运行时多态。</li></ul><h2 id="java构造方法"><a href="#java构造方法" class="headerlink" title="java构造方法"></a>java构造方法</h2><blockquote><p>在java中，一个新的对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。</p><p>Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。<br>Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。</p></blockquote><h2 id="接口和抽象类区别"><a href="#接口和抽象类区别" class="headerlink" title="接口和抽象类区别"></a>接口和抽象类区别</h2><p>java 类可以继承一个抽象类，实现多个接口，都不能被实例化</p><ul><li><ol><li>抽象类</li></ol></li></ul><p>抽象类定义为包含抽象方法的类(<em>不包含抽象方法，仅用abstract修饰的类也可以是抽象类，只不过没有抽象方法设计成的抽象类没多大意义</em>)，使用abstrac关键字修饰。</p><p>抽象类为继承而设计，抽象方法必须为public或protected,缺省默认为public，抽象类不能被实例化，如果一个类继承一个抽象类，必须实现所有的抽象方法，否则子类也必须定义为抽象类。</p><ul><li><ol><li>接口</li></ol></li></ul><p>接口定义为提供别人调用的方法或函数，java中使用interface定义，接口可以含有变量和方法，但是变量会被隐式指定为public static final变量，方法则会被隐式地指定为public abstrac方法，变量和方法也仅仅只能如此，否则会编译错误。</p><p>抽象类实现接口的时候，可以不实现接口的抽象方法。</p><ul><li><ol><li>区别</li></ol></li></ul><div class="table-container"><table><thead><tr><th></th><th></th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>构造函数</td><td>有</td><td>无</td></tr><tr><td>普通成员变量</td><td>有</td><td>无</td></tr><tr><td>非abstract 方法</td><td>有</td><td>无</td></tr><tr><td>访问修饰符</td><td>public, protected</td><td>默认也只能是public</td></tr><tr><td>静态方法</td><td>有</td><td>无</td></tr><tr><td>静态成员变量</td><td>访问类型任意</td><td>默认也只能是public static final</td></tr><tr><td>其他</td><td>单继承</td><td>多实现</td></tr></tbody></table></div><p><strong>语法层面讲</strong></p><p>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><p><strong>设计层面上的区别</strong></p><p>1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p><p>2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p><p>参考文档： <a href="https://www.cnblogs.com/dolphin0520/p/3811437.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3811437.html</a></p><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>进程：是并发执行的程序在执行过程中<strong>分配和管理资源</strong>的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。<br>线程：是进程的一个执行单元，比进程更小的独立运行的基本单位。线程也被称为轻量级进程。</p><p>一个程序至少有一个进程，一个进程至少有一个线程。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><p>区别：</p><p>进程和线程最大的区别在于不同的操作系统资源管理方式：</p><div class="table-container"><table><thead><tr><th></th><th></th><th>线程</th><th>进程</th></tr></thead><tbody><tr><td>地址空间</td><td>同一进程的线程间共享</td><td>进程间相互独立、不可见</td></tr><tr><td>并发性</td><td>高</td><td>低</td></tr><tr><td>资源开销</td><td>小，不利于资源管理</td><td>大，方便资源管理和利用</td></tr><tr><td>资源拥有</td><td>共享CPU 内存 I/O</td><td>进程间资源相互独立</td></tr><tr><td>通信</td><td>管道，消息队列，信号量，共享存储，Socket, Streams</td><td>共享内存，同步，wait/notify,管道通信</td></tr></tbody></table></div><p>如何选用：</p><p>对资源的管理和保护要求高，不限制开销和效率时，使用多进程。<br>要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。</p><h2 id="同步方法和同步块的区别"><a href="#同步方法和同步块的区别" class="headerlink" title="同步方法和同步块的区别"></a>同步方法和同步块的区别</h2><p>同步方法：默认使用this（成员方法）或者当前类的class对象（类方法）作为锁进行同步，使用关键字 synchronized修饰方法。</p><p>同步块：自定义锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法，用synchronized（object）{代码内容}进行修饰。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>定义：指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。</p><blockquote><p>产生死锁的4个必要条件：</p></blockquote><ul><li>互斥条件：同一个资源只能有一个进程占有，不能有两个或者两个以上的占有。</li><li>不可抢占条件：在一个进程所获取的资源在未使用完毕之前，资源申请者不能强行的从资源占有者手中抢夺资源，资源只能由占有者释放。</li><li>请求和保持条件：进程已经占有了一个资源，但是有申请新的资源；但是新申请的资源已经被别的进程占有了，此时该进程就会阻塞，但是在获取申请的资源之前他还会一直占有已占有的那个资源。</li><li>循环等待条件：存在一个循环等待序列，p1等待p2,p2等待p3,p3等待p1。形成一个进程循环等待。</li></ul><blockquote><p>如何避免死锁：</p></blockquote><p>(1)打破互斥条件：允许进程同时访问某些资源，但是，有的资源不允许被同时访问，就像打印机，这是由资源的本身来决定的，所以这个方法并没有什么实用的价值。</p><p>(2)打破不可抢占的条件：就是说允许进程强行从资源的占有者那里抢夺资源。这种方法实现起来很困难，会降低性能。</p><p>(3)打破占有申请条件：可以实现资源预先分配策略，在进程运行前一次性向系统申请他所需要的全部资源。如果进程所需的资源不能满足，则不分配任何资源，进程暂时不运行。(问题：1.在很多时候，一个进程在执行之前不可能知道它所有的全部资源，进程在执行的过程中，是动态的。2.资源利用率低。3.降低进程的并发性，因为资源有效，有加上存在浪费，能分配的所需全部资源的进程个数必然很少。)</p><p>(4)打破循环等待条件：实行资源的有序分配策略，把资源事先分类编号，按号分配，使进程在申请，占用资源时候不能形成环路，所有进程对资源的请求必须严格按照资源号递增的顺序提出，进程占用了小号的资源，才能申请大号资源。就会形成环路。(缺点：限制进程对资源的请求，同时对系统中的所有资源合理编号也是很有困难的，增加额外的系统开销。)</p><blockquote><p>死锁例子：</p></blockquote><p>进程A占有对象1的锁，进程B占有对象2的锁，进程A需要对象2的锁才能继续执行，所以进程A会等待进程B释放对象2的锁，而进程B需要对象1的锁才能继续执行，同样会等待进程A释放对象1的锁，由于这两个进程都不释放已占有的锁，所以导致他们进入无限等待中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// LockTest.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String obj1 = <span class="string">"obj1"</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String obj2 = <span class="string">"obj2"</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      LockA la = <span class="keyword">new</span> LockA();</span><br><span class="line">      <span class="keyword">new</span> Thread(la).start();</span><br><span class="line">      LockB lb = <span class="keyword">new</span> LockB();</span><br><span class="line">      <span class="keyword">new</span> Thread(lb).start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockA</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">" LockA 开始执行"</span>);</span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LockTest.obj1) &#123;</span><br><span class="line">               System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">" LockA 锁住 obj1"</span>);</span><br><span class="line">               Thread.sleep(<span class="number">3000</span>); <span class="comment">// 此处等待是给B能锁住机会</span></span><br><span class="line">               <span class="keyword">synchronized</span> (LockTest.obj2) &#123;</span><br><span class="line">                  System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">" LockA 锁住 obj2"</span>);</span><br><span class="line">                  Thread.sleep(<span class="number">60</span> * <span class="number">1000</span>); <span class="comment">// 为测试，占用了就不放</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockB</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">" LockB 开始执行"</span>);</span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LockTest.obj2) &#123;</span><br><span class="line">               System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">" LockB 锁住 obj2"</span>);</span><br><span class="line">               Thread.sleep(<span class="number">3000</span>); <span class="comment">// 此处等待是给A能锁住机会</span></span><br><span class="line">               <span class="keyword">synchronized</span> (LockTest.obj1) &#123;</span><br><span class="line">                  System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">" LockB 锁住 obj1"</span>);</span><br><span class="line">                  Thread.sleep(<span class="number">60</span> * <span class="number">1000</span>); <span class="comment">// 为测试，占用了就不放</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><p>Mon Jul 16 22:40:18 CST 2018LockA 开始执行<br>Mon Jul 16 22:40:18 CST 2018 LockA 锁住 obj1<br>Mon Jul 16 22:40:18 CST 2018 LockB 开始执行<br>Mon Jul 16 22:40:18 CST 2018 LockB 锁住 obj2</p><p><strong>如何解决死锁：</strong></p><p>为了解决这个问题，我们不使用显示的去锁，我们用信号量去控制。</p><p>信号量可以控制资源能被多少线程访问，这里我们指定只能被一个线程访问，就做到了类似锁住。而信号量可以指定去获取的超时时间，我们可以根据这个超时时间，去做一个额外处理。</p><p>对于无法成功获取的情况，一般就是重复尝试，或指定尝试的次数，也可以马上退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnLockTest</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String obj1 = <span class="string">"obj1"</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore a1 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String obj2 = <span class="string">"obj2"</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore a2 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      LockAa la = <span class="keyword">new</span> LockAa();</span><br><span class="line">      <span class="keyword">new</span> Thread(la).start();</span><br><span class="line">      LockBb lb = <span class="keyword">new</span> LockBb();</span><br><span class="line">      <span class="keyword">new</span> Thread(lb).start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockAa</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">" LockA 开始执行"</span>);</span><br><span class="line">         <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UnLockTest.a1.tryAcquire(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">               System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">" LockA 锁住 obj1"</span>);</span><br><span class="line">               <span class="keyword">if</span> (UnLockTest.a2.tryAcquire(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                  System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">" LockA 锁住 obj2"</span>);</span><br><span class="line">                  Thread.sleep(<span class="number">60</span> * <span class="number">1000</span>); <span class="comment">// do something</span></span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">"LockA 锁 obj2 失败"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">"LockA 锁 obj1 失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            UnLockTest.a1.release(); <span class="comment">// 释放</span></span><br><span class="line">            UnLockTest.a2.release();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 马上进行尝试，现实情况下do something是不确定的</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockBb</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">" LockB 开始执行"</span>);</span><br><span class="line">         <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UnLockTest.a2.tryAcquire(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">               System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">" LockB 锁住 obj2"</span>);</span><br><span class="line">               <span class="keyword">if</span> (UnLockTest.a1.tryAcquire(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                  System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">" LockB 锁住 obj1"</span>);</span><br><span class="line">                  Thread.sleep(<span class="number">60</span> * <span class="number">1000</span>); <span class="comment">// do something</span></span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">"LockB 锁 obj1 失败"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">"LockB 锁 obj2 失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            UnLockTest.a1.release(); <span class="comment">// 释放</span></span><br><span class="line">            UnLockTest.a2.release();</span><br><span class="line">            Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>); <span class="comment">// 这里只是为了演示，所以tryAcquire只用1秒，而且B要给A让出能执行的时间，否则两个永远是死锁</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h2><p>finalize()方法什么时候被调用?析构函数(finalization)的目的是什么？</p><p>调用时机：当垃圾回收器要宣告一个对象死亡时，至少要经过两次标记过程：如果对象在进行可达性分析后发现没有和GC Roots相连接的引用链，就会被第一次标记，并且判断是否执行finalizer( )方法，如果对象覆盖finalizer()方法且未被虚拟机调用过，那么这个对象会被放置在F-Queue队列中，并在稍后由一个虚拟机自动建立的低优先级的Finalizer线程区执行触发finalizer( )方法，但不承诺等待其运行结束。</p><p>finalization的目的：对象逃脱死亡的最后一次机会。（只要重新与引用链上的任何一个对象建立关联即可。）但是不建议使用，运行代价高昂，不确定性大，且无法保证各个对象的调用顺序。可用try-finally或其他替代。</p><p>GC决定回收某对象的时候，就会运行对象的finalize()方法，一般情况下不用重写该方法。</p><p>最主要的用途是，回收特殊渠道申请的内存，<strong>native方法</strong>。例如使用JNI调用C++程序的时候，finalize()方法就回收这部分的内存。</p><h2 id="System-gc-和Runtime-gc-会做什么事情？"><a href="#System-gc-和Runtime-gc-会做什么事情？" class="headerlink" title="System.gc()和Runtime.gc()会做什么事情？"></a>System.gc()和Runtime.gc()会做什么事情？</h2><p>这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。</p><h2 id="JVM内存分配策略、各个代区、GC类别"><a href="#JVM内存分配策略、各个代区、GC类别" class="headerlink" title="JVM内存分配策略、各个代区、GC类别"></a>JVM内存分配策略、各个代区、GC类别</h2><h3 id="各个代区"><a href="#各个代区" class="headerlink" title="各个代区"></a>各个代区</h3><blockquote><p>年轻代(Young Generation)：</p></blockquote><p>所有新生对象首先放在年轻代中。年轻代的目标就是尽可能快速的收集掉那些生<br>命周期短的对象。年轻代分三个区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在<br>Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这<br>个 Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了<br>的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区<br>(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时<br>存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第<br>一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，<br>Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减<br>少被放到年老代的可能。</p><blockquote><p>年老代(Old Generation)：</p></blockquote><p>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认<br>为年老代中存放的都是一些生命周期较长的对象。</p><blockquote><p>永久代(Permanent Generation):</p></blockquote><p>用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应<br>用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持<br>久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=<n>进行设置.</n></p><h3 id="GC类别"><a href="#GC类别" class="headerlink" title="GC类别"></a>GC类别</h3><ul><li>Minor GC: 从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC, 因大多数新生对象生命周期很短，所以MinorGC通常很频繁，回收速度也较快;</li><li>FullGC: 针对整个新生代、老生代、元空间（metaspace，java8以上版本取代永久代(perm gen)）的全局范围的GC, 执行频率低，回收速度慢。</li><li>Major GC: 定义不清楚，有的地方同FullGC（深入理解java虚拟机），有的地方指的是清理永久代。</li></ul><h3 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h3><ol><li>对象优先在Eden分配</li></ol><p>一般情况下，对象会在新生代的Eden区分配，Eden区没有足够空间时，虚拟机会 发起一次MinorGC；当MinorGC时，若无法放入survivor空间，就会再通过分配担保机制转移到老年代中；</p><ol><li>大对象直接进入老年代</li></ol><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。<br>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。<br>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。</p><ol><li>长期存活的对象进入老年代</li></ol><p>通过 -XX:MaxTenuringThreshold参数设置；每MinorGC一次还存活在Survivor中，则年龄加1；</p><ol><li>动态对象年龄判定</li></ol><p>虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p><ol><li>空间分配担保</li></ol><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC。</p><h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><p>MinorGC: Eden区满时触发；FullGC也会伴随有MinorGC；通常会使得Old gen变大；</p><p>FullGC：<br>a. MinorGC触发前，检查历次进入老年代的平均大小，若小于则FullGC；<br>b. 如果有永久代（perm gen），在不足哆分配时，触发FullGC；<br>c. 调用System.gc()，提醒JVM FullGC，但不可控；</p><h2 id="串行-serial-收集器和吞吐量-throughput-收集器的区别是什么？"><a href="#串行-serial-收集器和吞吐量-throughput-收集器的区别是什么？" class="headerlink" title="串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？"></a>串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？</h2><p>串行GC：整个扫描和复制过程均采用单线程的方式，相对于吞吐量GC来说简单；适合于单CPU、客户端级别。串行收集器在GC时会停止其他所有工作线程（stop-the-world），CPU利用率是最高的，所以适用于要求高吞吐量（throughput）的应用，但停顿时间（pause time）会比较长，所以对web应用来说就不适合，因为这意味着用户等待时间会加长。</p><p>吞吐量GC：采用多线程的方式来完成垃圾收集（新生代），适合于吞吐量要求较高的场合，比较适合中等和大规模的应用程序，关注点在于达到一个可控制的吞吐量，另外吞吐量收集器有自适应调节策略的能力。采用并行收集器停顿时间很短，回收效率高，适合高频率执行。</p><h2 id="java中，对象在什么情况下被回收？"><a href="#java中，对象在什么情况下被回收？" class="headerlink" title="java中，对象在什么情况下被回收？"></a>java中，对象在什么情况下被回收？</h2><p>当一个对象到GC Roots不可达时，在下一个垃圾回收周期中尝试回收该对象，如果该对象重写了finalize()方法，并在这个方法中成功自救(将自身赋予某个引用)，那么这个对象不会被回收。但如果这个对象没有重写finalize()方法或者已经执行过这个方法，也自救失败，该对象将会被回收。</p><h2 id="JVM的永久代中会发生垃圾回收么？"><a href="#JVM的永久代中会发生垃圾回收么？" class="headerlink" title="JVM的永久代中会发生垃圾回收么？"></a>JVM的永久代中会发生垃圾回收么？</h2><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区<br>(注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p><h2 id="java中的异常"><a href="#java中的异常" class="headerlink" title="java中的异常"></a>java中的异常</h2><p>java.lang.Throwable 是所有异常的超类</p><p>Error: 是错误<br>Exception: 是异常</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>1. 受检查异常</strong></p><p>从程序角度来说，是必须经过捕捉处理的异常，要么使用try…catch,要么使用throws 语句声明抛出，否则编译通不过</p><p>例如java.io.IOException</p><p><strong>2. 不受检查异常（运行时异常，RuntimeException）</strong></p><p>运行时发生，即时不用try…catch或者throws语句声明，会编译通过。例如java.lang.NullPointerException<br>写程序的时候尽量避免</p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>当程序发生不可控的错误是，通常是通知用户并终止程序的运行。例如OutOfMemoryError,动态链接失败，虚拟机错误等。</p><h2 id="什么是JDBC"><a href="#什么是JDBC" class="headerlink" title="什么是JDBC"></a>什么是JDBC</h2><p>JDBC（Java DataBase Connectivity）,是一套面向对象的应用程序接口（API），制定了统一的访问各类关系数据库的标准接口，为各个数据库厂商提供了标准的实现。通过JDBC技术，开发人员可以用纯Java语言和标准的SQL语句编写完整的数据库应用程序，并且真正地实现了软件的跨平台性。</p><p>通常情况下使用JDBC完成以下操作：<br>1.同数据库建立连接；<br>2.向数据库发送SQL语句；<br>3.处理从数据库返回的结果；</p><p>JDBC具有下列优点：<br>1.JDBC与ODBC(Open Database Connectivity，即开放数据库互连）十分相似，便于软件开发人员理解；<br>2.JDBC使软件开发人员从复杂的驱动程序编写工作中解脱出来，可以完全专注于业务逻辑开发；<br>3.JDBC支持多种关系型数据库，大大增加了软件的可移植性；<br>4.JDBC API是面向对象的，软件开发人员可以将常用的方法进行二次封装，从而提高代码的重用性；</p><p>JDBC驱动：<br>JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。</p><p>一句话总结，<strong>在使用jdbc前，应该保证相应的Driver类已经被加载到jvm中，并且完成了类的初始化工作就行了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span> ); <span class="comment">// 初始化参数指定的类，并返回此类对应的对象</span></span><br><span class="line">com.mysql.jdbc.Driver driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line">ClassLoader cl = <span class="keyword">new</span> ClassLoader(); </span><br><span class="line">cl.loadClass(<span class="string">"com.mysql.jdbc.Driver"</span> ); </span><br><span class="line"><span class="comment">// 以上三种方法其实都可以加载驱动</span></span><br><span class="line"><span class="comment">// 加载完驱动就可以使用驱动管理器来建立链接了</span></span><br><span class="line">Connection con = DriverManager.getConnection(url,user,psw);</span><br></pre></td></tr></table></figure><h2 id="java-RMI"><a href="#java-RMI" class="headerlink" title="java RMI"></a>java RMI</h2><p>java RMI(Remote Method Invocation), java的远程方法调用是java API对远程过程调用（RPC）提供的面向对象的等价形式，能够让某个java虚拟机上的对象像调用本地对象一样调用另一个java虚拟机中对象的方法，支持直接传输序列化的java对象和分布式垃圾回收。</p><p>RMI远程调用步骤：</p><p>1，客户对象调用客户端辅助对象上的方法</p><p>2，客户端辅助对象打包调用信息（变量，方法名），通过网络发送给服务端辅助对象</p><p>3，服务端辅助对象将客户端辅助对象发送来的信息解包，找出真正被调用的方法以及该方法所在对象</p><p>4，调用真正服务对象上的真正方法，并将结果返回给服务端辅助对象</p><p>5，服务端辅助对象将结果打包，发送给客户端辅助对象</p><p>6，客户端辅助对象将返回值解包，返回给客户对象</p><p>7，客户对象获得返回值</p><p>对于客户对象来说，步骤2-6是完全透明的</p><p>参考文档：</p><ul><li><a href="https://blog.csdn.net/a19881029/article/details/9465663" target="_blank" rel="noopener">Java RMI详解</a></li></ul><h2 id="RMI-体系的基本原则："><a href="#RMI-体系的基本原则：" class="headerlink" title="RMI 体系的基本原则："></a>RMI 体系的基本原则：</h2><p>RMI体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。RMI允许定义行为的代码和实现行为的代码相分离，并且运行在不同的JVM上。</p><h2 id="RMI体系结构分层"><a href="#RMI体系结构分层" class="headerlink" title="RMI体系结构分层"></a>RMI体系结构分层</h2><p>存根和骨架层(Stub and Skeleton layer)：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的RMI服务。</p><p>远程引用层(Remote Reference Layer)：RMI体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的。</p><p>传输层(Transport layer)：这一层负责连接参与服务的两个JVM。这一层是建立在网络上机器间的TCP/IP连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略。</p><h2 id="分布式垃圾回收"><a href="#分布式垃圾回收" class="headerlink" title="分布式垃圾回收"></a>分布式垃圾回收</h2><p>DGC叫做分布式垃圾回收。RMI使用DGC来做自动垃圾回收。因为RMI包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。</p><p>概念：<br>    1)Java虚拟机中，一个远程对象不仅会被本地虚拟机内的变量引用，还会被远程引用。<br>    2)只有当一个远程对象不受到任何本地引用和远程引用，这个远程对象才会结束生命周期。</p><p>说明：<br>    1)服务端的一个远程对象在3个地方被引用：<br>        1&gt;服务端的一个本地对象持有它的本地引用<br>        2&gt;服务端的远程对象已经注册到rmiregistry注册表中，也就是说，rmiregistry注册表持有它的远程引用。<br>        3&gt;客户端获得远程对象的存根对象，也就是说，客户端持有它的远程引用。<br>    2)服务端判断客户端是否持有远程对象引用的方法：<br>        1&gt;当客户端获得一个服务端的远程对象的存根时，就会向服务器发送一条租约(lease)通知，以告诉服务器自己持有了这个远程对象的引用了。<br>        2&gt;客户端定期地向服务器发送租约通知，以保证服务器始终都知道客户端一直持有着远程对象的引用。<br>        3&gt;租约是有期限的，如果租约到期了，服务器则认为客户端已经不再持有远程对象的引用了。</p><h2 id="Serializaton-和-Deserialization"><a href="#Serializaton-和-Deserialization" class="headerlink" title="Serializaton 和 Deserialization"></a>Serializaton 和 Deserialization</h2><p>序列化和反序列化的对象必须实现serializable 接口，该接口没有抽象方法，只是为了标注对象可以被序列化，然后使用一个输出流就可以构造一个ObjectOutputStream(对象)，调用writeObject方法就可以将任意对象序列化输出，恢复的话则使用输出流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象序列化测试.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiong Raorao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018-07-17-11:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    a.setName(<span class="string">"hhh"</span>);</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\oos"</span>));</span><br><span class="line">    oos.writeObject(a);</span><br><span class="line">    oos.close();</span><br><span class="line"></span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"D:\\oos"</span>));</span><br><span class="line">    A aa = (A) ois.readObject();</span><br><span class="line">    System.out.println(aa.getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h1><h2 id="什么是-Servlet"><a href="#什么是-Servlet" class="headerlink" title="什么是 Servlet?"></a>什么是 Servlet?</h2><p>Servlet是用来处理客户端请求并产生动态网页内容的Java类。Servlet主要是用来处理或者是存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。</p><h3 id="servlet的体系结构："><a href="#servlet的体系结构：" class="headerlink" title="servlet的体系结构："></a>servlet的体系结构：</h3><p>所有的Servlet都必须要实现的核心的接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者是间接实现这个接口，或者是继承javax.servlet.GenericServlet或者javax.servlet.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务。</p><p>参考文档： </p><ul><li><a href="http://blog.csdn.net/a236209186/article/details/51262646" target="_blank" rel="noopener">servlet的体系结构</a></li></ul><h3 id="servlet的生命周期和工作原理"><a href="#servlet的生命周期和工作原理" class="headerlink" title="servlet的生命周期和工作原理"></a>servlet的生命周期和工作原理</h3><ol><li>初始化阶段，调用init()方法</li><li>响应用户请求的方法，调用service()方法，自己实现doGet和doPost方法</li><li>终止阶段，调用destroy()方法</li></ol><p><img src="/images/20170928102245610.png" alt=""></p><p>1：Web Client向Servlet容器(tomcat)发出Http请求<br>2：Servlet容器接收Web Client的请求<br>3：Servlet容器创建一个HttpRequest对象，将Web Client请求的信息封装到这个对象中。<br>4：Servlet容器创建一个HttpResponse对象<br>5：Servlet容器调用HttpServlet对象的service方法，把HttpRequest对象与HttpResponse对象作为参数传递给HttpServlet对象。<br>6：HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息<br>7：HttpServlet调用HttpResponse对象的有关方法，生成响应数据<br>8：Servlet容器把HttpServlet的响应结果传入Web Client。</p><h2 id="HTTP响应结构"><a href="#HTTP响应结构" class="headerlink" title="HTTP响应结构"></a>HTTP响应结构</h2><p>http响应由三个部分组成：</p><ul><li>状态码(Status Code)：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码HttpServletResponse.SC_OK。</li><li>HTTP头部(HTTP Header)：它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。如何在Serlet中检索HTTP的头部看这里。</li><li>主体(Body)：它包含了响应的内容。它可以包含HTML代码，图片，等等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的。</li></ul><h2 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h2><p>cookie是web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie，例如密码填充等。</p><p>seesion是存储在服务器端的信息，客户端访问服务器的时候，服务器把客户端信息已某种形式记录在服务器上。客户端浏览器再次访问服务器的时候， 服务器只需要在session中查找该用户的状态就可以了。如果说cookie机制是通过检查客户身上的“通信证”，那么session机制就是通过检查服务器上的“客户明细表”来确认客户身份。</p><p>区别：</p><ul><li>存储位置：cookie在客户端浏览器存储，session在服务器端存储</li><li>安全性：cookie安全性低，session安全性高</li><li>数据量：单个cookie只能保存不大于4k的数据，且只能是string，很多浏览器一个站点最多保存20个cookie，session可以存储任意的java对象</li></ul><p>将登陆信息等重要信息存放为SESSION<br>其他信息如果需要保留，可以放在COOKIE中</p><h2 id="HTTP隧道"><a href="#HTTP隧道" class="headerlink" title="HTTP隧道"></a>HTTP隧道</h2><p>HTTP隧道是一种利用HTTP或者是HTTPS把多种网络协议封装起来进行通信的技术。因此，HTTP协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成HTTP的请求就是HTTP隧道。</p><h2 id="sendRedirect-和forward-方法有什么区别？"><a href="#sendRedirect-和forward-方法有什么区别？" class="headerlink" title="sendRedirect()和forward()方法有什么区别？"></a>sendRedirect()和forward()方法有什么区别？</h2><p>sendRedirect()方法会创建一个新的请求，而forward()方法只是把请求转发到一个新的目标上。重定向(redirect)以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发(forwarding)以后，之前请求作用域范围以内的对象还是能访问的。一般认为sendRedirect()比forward()要慢。</p><h2 id="URL编码和URL解码"><a href="#URL编码和URL解码" class="headerlink" title="URL编码和URL解码"></a>URL编码和URL解码</h2><p>URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。</p><h2 id="JSP如何被处理的"><a href="#JSP如何被处理的" class="headerlink" title="JSP如何被处理的"></a>JSP如何被处理的</h2><p>客户端通过浏览器发送jsp请求，服务器端接受到请求后，判断是否是第一次请求该页面，或者该页面是否改变，若是，服务器将jsp页面翻译为servlet，jvm将servlet编译为.class文件，字节码文件加载到服务器内存上执行，服务器将处理结果以.html页面的形式返回给客户端，若该页面不是第一次请求，则省略翻译和编译的步骤，直接执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java基础&quot;&gt;&lt;a href=&quot;#java基础&quot; class=&quot;headerlink&quot; title=&quot;java基础&quot;&gt;&lt;/a&gt;java基础&lt;/h1&gt;&lt;h2 id=&quot;方法重载和方法重写&quot;&gt;&lt;a href=&quot;#方法重载和方法重写&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="笔记" scheme="http://xraorao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://xraorao.top/categories/%E7%AC%94%E8%AE%B0/java/"/>
    
    
      <category term="笔记" scheme="http://xraorao.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://xraorao.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>常见查找算法</title>
    <link href="http://xraorao.top/2018/07/14/%E5%B8%B8%E8%A7%81%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://xraorao.top/2018/07/14/常见查找算法/</id>
    <published>2018-07-14T00:25:56.000Z</published>
    <updated>2018-07-14T08:24:16.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算。这里介绍常见的几种查找算法。</p><p>查找定义：根据给定的某个值，在查找变中确定一个其关键字等于给定值的数据元素</p><p>查找算法分类：</p><p>（1）静态查找和动态查找:<br>静态或则动态都是针对查找表而言的，静态表指的是只作查找的表，动态表指查找表中有删除和插入操作的表  </p><p>静态表查找方法：顺序表查找、有序表查找、线性索引查找<br>动态表查找方法：二叉排序树、平衡二叉树（AVL树）、多路查找树（B树）</p><p>（2）无序查找和有序查找；无序查找：被查找的数列有序无序均可。有序查找：被查找的数列必须为有序数列</p><p>平均查找长度（Average Search Length, ASL）：需和制定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度</p><p>对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL = Pi*Ci的和。<br>Pi：查找表中第i个数据元素的概率。<br>Ci：找到第i个数据元素时已经比较过的次数。</p><h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><p><strong>说明：顺序查找适合于存储结构为顺序或者链接存储的线性表</strong></p><p>基本思想：顺序查找也称为线性查找，是在一个已知无(或有序）序队列中找出与给定关键字相同的数的具体位置。原理是让关键字与队列中的数从第一个开始逐个比较，直到找出与给定关键字相同的数为止，它的缺点是效率低下。</p><p>复杂度： O(N)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sequenceSearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> des)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] == des) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p><strong>说明：二分查找为有序查找，数列必须有序，否则需要先进性排序操作</strong></p><p>基本思想：也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。</p><p>复杂度：最坏为 <script type="math/tex">\log_2 (n+1)</script>,期望时间复杂度为<script type="math/tex">O(\log_2 n))</script></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 目标数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 关键字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 目标数组的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> binarySearch(arr, key, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key, <span class="keyword">int</span> low, <span class="keyword">int</span> hight)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mid = (low + hight) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (arr[mid] == key) &#123;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; key) &#123;</span><br><span class="line">    low = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> binarySearch(arr, key, low, hight);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    hight = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> binarySearch(arr, key, low, hight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h1><p>基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率，当然插值查找也属于有序查找。</p><p>对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p><p>复杂度分析：查找成功或者失败的时间复杂度均为<script type="math/tex">O(\log_2 (\log_2 n))</script></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 插入查找</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arr 目标数组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key 关键字</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 目标数组的索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> insertSearch(arr, key, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把二分查找的比例参数改为自适应的，让mid值的变化更加靠近关键字key，间接减少比较次数</span></span><br><span class="line">    <span class="keyword">int</span> mid = low + (key - arr[low]) / (arr[high] - arr[low]) * (high - low);</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] == key) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; key) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> insertSearch(arr, key, low, high);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> insertSearch(arr, key, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h1><p>黄金分割：是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。</p><p>大家记不记得斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。</p><p>基本思想：也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。</p><p>相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素比较，比较结果分三种情况：<br>　　1）相等，mid位置的元素即为所求</p><p>　　2）&gt;，low=mid+1;</p><pre><code> 3）&lt;，high=mid-1。</code></pre><p>　　斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;</p><p> 开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种</p><p>　　1）相等，mid位置的元素即为所求</p><p>　　2）&gt;，low=mid+1,k-=2;</p><p>　　说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。</p><p>　　3）&lt;，high=mid-1,k-=1。</p><p>　　说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。</p><p>复杂度分析：最坏情况下，时间复杂度为<script type="math/tex">O(\log_2 n)</script>，且其期望复杂度也为<script type="math/tex">O(\log_2 n)</script>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契查找.cpp </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_size=<span class="number">20</span>;<span class="comment">//斐波那契数组的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造一个斐波那契数组*/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> * F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    F[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    F[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;max_size;++i)</span><br><span class="line">        F[i]=F[i<span class="number">-1</span>]+F[i<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义斐波那契查找法*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FibonacciSearch</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span>  <span class="comment">//a为要查找的数组,n为要查找的数组长度,key为要查找的关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high=n<span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> F[max_size];</span><br><span class="line">  Fibonacci(F);<span class="comment">//构造一个斐波那契数组F </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>)<span class="comment">//计算n位于斐波那契数列的位置</span></span><br><span class="line">      ++k;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>  * temp;<span class="comment">//将数组a扩展到F[k]-1的长度</span></span><br><span class="line">  temp=<span class="keyword">new</span> <span class="keyword">int</span> [F[k]<span class="number">-1</span>];</span><br><span class="line">  <span class="built_in">memcpy</span>(temp,a,n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;F[k]<span class="number">-1</span>;++i)</span><br><span class="line">     temp[i]=a[n<span class="number">-1</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(key&lt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">      high=mid<span class="number">-1</span>;</span><br><span class="line">      k-=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">     low=mid+<span class="number">1</span>;</span><br><span class="line">     k-=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(mid&lt;n)</span><br><span class="line">           <span class="keyword">return</span> mid; <span class="comment">//若相等则说明mid即为查找到的位置</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> n<span class="number">-1</span>; <span class="comment">//若mid&gt;=n则说明是扩展的数值,返回n-1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">delete</span> [] temp;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">16</span>,<span class="number">24</span>,<span class="number">35</span>,<span class="number">47</span>,<span class="number">59</span>,<span class="number">62</span>,<span class="number">73</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> key=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> index=FibonacciSearch(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>),key);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;key&lt;&lt;<span class="string">" is located at:"</span>&lt;&lt;index;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树表查找"><a href="#树表查找" class="headerlink" title="树表查找"></a>树表查找</h1><h2 id="1-最简单的鼠标查找—二叉树查找算法"><a href="#1-最简单的鼠标查找—二叉树查找算法" class="headerlink" title="1. 最简单的鼠标查找—二叉树查找算法"></a>1. 最简单的鼠标查找—二叉树查找算法</h2><p>基本思想：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 </p><p><code>二叉查找树</code>（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：</p><p>　　1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p><p>　　2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p><p>　　3）任意节点的左、右子树也分别为二叉查找树。</p><p><strong>二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。</strong></p><p><img src="/images/1333691114_6839.jpg" alt="二叉查找树"></p><p>复杂度分析：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。</p><p>基于对二叉查找树进行优化，进而可以得到其他树表查找算法，如<code>平衡树</code>，<code>红黑树</code>等高效算法</p><h2 id="2-平衡查找树—2-3查找树（2-3-Tree"><a href="#2-平衡查找树—2-3查找树（2-3-Tree" class="headerlink" title="2. 平衡查找树—2-3查找树（2-3 Tree)"></a>2. 平衡查找树—2-3查找树（2-3 Tree)</h2><p>为了保证在最差的情况下也能达到logN的效率，引入了平衡查找树。因此需要保证树在插入之后始终保持平衡状态，这就是<strong>平衡查找树</strong>。</p><p>2-3查找树：和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：</p><p>（1）要么为空，要么：<br>（2）对于2节点，该节点保存一个key及其对应的value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。<br>（3）对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。</p><p><strong>2-3查找树的性质：</strong></p><p>1）如果中序遍历2-3查找树，就可以得到排好序的序列；</p><p>2）在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。）</p><p>复杂度分析：</p><p>2-3树的查找效率与树的高度是息息相关的。</p><ul><li>在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN</li><li>在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN</li></ul><h2 id="3-平衡查找树—红黑树（Red-Black-Tree"><a href="#3-平衡查找树—红黑树（Red-Black-Tree" class="headerlink" title="3. 平衡查找树—红黑树（Red-Black Tree)"></a>3. 平衡查找树—红黑树（Red-Black Tree)</h2><p>2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgn，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，于是就有了一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。</p><p>基本思想：红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。</p><p><img src="/images/270024368439888.png" alt=""></p><p><strong>红黑树定义：</strong><br>红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：</p><ul><li>红色节点向左倾斜</li><li>一个节点不可能有两个红色链接</li><li>整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。</li></ul><p>还有一种定义：</p><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或者黑色，除了二叉查找树的要求外，还满足如下要求：</p><p>（1）节点是红色或者黑色<br>（2）根节点是黑色<br>（3）每个叶节点（NIL节点，空节点）是黑色的<br>（4）每个红色节点的两个子节点都是黑色（从每个叶子到根节点的所有路径上不能有两个连续的红色节点）<br>（5）从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点</p><p>这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。</p><p><img src="/images/270024403113529.png" alt=""></p><p>红黑树的性质：整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同（2-3树的第2）性质，从根节点到叶子节点的距离都相等）。</p><p>复杂度分析：最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即红黑相间的路径长度是全黑路径长度的2倍。</p><p><img src="/images/270027368747653.png" alt=""></p><p>红黑树的平均高度大约为logn。</p><h2 id="4-B树和B-树（B-Tree-B-Tree）"><a href="#4-B树和B-树（B-Tree-B-Tree）" class="headerlink" title="4. B树和B+树（B Tree/B+ Tree）"></a>4. B树和B+树（B Tree/B+ Tree）</h2><p>平衡查找树中的2-3树以及其实现红黑树。2-3树种，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。</p><p>维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。</p><p>B树定义：</p><p>　　B树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。</p><p>根节点至少有两个子节点</p><p>每个节点有M-1个key，并且以升序排列</p><p>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</p><p>其它节点至少有M/2个子节点</p><p>　　下图是一个M=4 阶的B树:</p><p><img src="/images/290047034539184.png" alt=""></p><p>　可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。B树的插入及平衡化操作和2-3树很相似，这里就不介绍了。下面是往B树中依次插入<br>6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4<br>的演示动画：</p><p><img src="/images/btreebuild.gif" alt=""></p><p>B+树定义：</p><p>　　B+树是对B树的一种变形树，它与B树的差异在于：</p><p>有k个子结点的结点必然有k个关键码；<br>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。<br>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。<br>　　如下图，是一个B+树:<br><img src="/images/290050048129679.png" alt=""></p><p>下图是B+树的插入动画：</p><p><img src="/images/Bplustreebuild.gif" alt=""></p><p><strong>B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。</strong></p><p>B+ 树的优点在于：</p><ul><li><p>由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。</p></li><li><p>B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</p></li></ul><p><strong>但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。</strong></p><p>　B/B+树常用于文件系统和数据库系统中，它通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。它广泛用于文件系统及数据库中，如：</p><p>Windows：HPFS文件系统；<br>Mac：HFS，HFS+文件系统；<br>Linux：ResiserFS，XFS，Ext3FS，JFS文件系统；<br>数据库：ORACLE，MYSQL，SQLSERVER等中。<br>　　有关B/B+树在数据库索引中的应用，请看张洋的<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a>这篇文章，这篇文章对MySQL中的如何使用B+树进行索引有比较详细的介绍，推荐阅读。</p><p>参考文档：</p><ul><li><a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">B树和B+树的插入、删除图文详解</a></li><li><a href="https://www.cnblogs.com/vincently/p/4526560.html" target="_blank" rel="noopener">【经典数据结构】B树与B+树</a></li><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></li></ul><p>树表查找总结：</p><p>　　二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。在二叉查找树的基础上进行优化，我们可以使用平衡查找树。平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。</p><p>　　除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。</p><p><img src="/images/270027378905711.png" alt="查找"></p><h1 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h1><p>分块查找又称索引顺序查找，它是顺序查找的一种改进方法。<br>　　算法思想：将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……<br>　　算法流程：<br>　　step1 先选取各块中的最大关键字构成一个索引表；<br>　　step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。</p><h1 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h1><h2 id="什么是哈希表（Hash）？"><a href="#什么是哈希表（Hash）？" class="headerlink" title="什么是哈希表（Hash）？"></a>什么是哈希表（Hash）？</h2><p>哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素”分类”，然后将这个元素存储在相应”类”所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了”冲突”，换句话说，就是把不同的元素分在了相同的”类”之中。后面我们将看到一种解决”冲突”的简便做法。</p><p><strong>总的来说，”直接定址”与”解决冲突”是哈希表的两大特点。</strong></p><p>只接定址可以提高查找速度，但是需要大量存储空间，通常查找的时间复杂度越低，空间复杂度越高</p><p>数组的特点是：寻址容易，插入和删除困难；</p><p>而链表的特点是：寻址困难，插入和删除容易。</p><p>那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。</p><h2 id="什么是哈希函数？"><a href="#什么是哈希函数？" class="headerlink" title="什么是哈希函数？"></a>什么是哈希函数？</h2><p>　　哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。</p><p>算法思想：哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。</p><h3 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h3><p>　　1）用给定的哈希函数构造哈希表；<br>　　2）根据选择的冲突处理方法解决地址冲突；<br>　　　　常见的解决冲突的方法：拉链法和线性探测法。<br>　　3）在哈希表的基础上执行哈希查找。</p><p>哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。</p><h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>　　单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。</p><h3 id="哈希函数的构造："><a href="#哈希函数的构造：" class="headerlink" title="哈希函数的构造："></a>哈希函数的构造：</h3><p>采用哈希函数的关键作用是减少需要被处理的数组大小。在构造散列函数时有几点需要加以注意：</p><ul><li>其一、散列函数的定义域必须包括需要存储的全部数据元素的关键字，而如果散列表允许有m个地址时，其值域必须在0到m-1之间；</li><li>其二、散列函数计算出来的地址应能均匀分布在整个地址空间中，若key是从关键字集合中随机抽取的一个关键字，散列函数应能以同等概率取0到m-1中的每一个值；</li><li>其三、散列函数应是简单的，能在较短的时间内计算出结果。下面我们介绍几个散列函数。</li></ul><h4 id="1-直接地址法"><a href="#1-直接地址法" class="headerlink" title="1. 直接地址法"></a>1. 直接地址法</h4><p>此类函数取关键字的某个线性函数值作为散列地址：Hash（key）=a*key+c （其中a、c是整常数）</p><p>这类散列函数是一对一的映射，一般不会产生冲突，但是，它要求散列地址空间的大小与关键字集合的大小相同，这种要求是很苛刻的。特别是当关键字集合很大而且又不连续时，这种方法就不太适宜。</p><h4 id="2-数字分析法"><a href="#2-数字分析法" class="headerlink" title="2. 数字分析法"></a>2. 数字分析法</h4><p>设数据表的长度为n，数据元素的关键字是一个d位数，关键字上每一位可能有r种不同的符号。这r种不同的符号在各位上出现的概率不一定相同，可能在某些位上分布均匀，出现的机会均等；在某些位上分布不均匀，只有某几种符号经常出现。数字分析法就是根据散列表的大小，在关键字中选取某些分布均匀的若干位作为散列地址。</p><h4 id="3-除留余数法"><a href="#3-除留余数法" class="headerlink" title="3. 除留余数法"></a>3. 除留余数法</h4><p>设散列表地址空间大小为m，取一个不大于m，但最接近于或等于m的质数p，或者选取一个不含有小于20的质因数的合数作为除数，除留余数法的散列函数为：</p><p>Hash（key）=key % p （p≤m, p 避免去2的幂）</p><h4 id="4-乘余取整法（乘法散列法）"><a href="#4-乘余取整法（乘法散列法）" class="headerlink" title="4. 乘余取整法（乘法散列法）"></a>4. 乘余取整法（乘法散列法）</h4><p>使用此方法时，先让关键字key乘上一个常数a(0＜a＜1)，提取乘积的小数部分，然后再用整数n乘以这个值，对结果向下取整，把它作为散列地址</p><script type="math/tex; mode=display">h(k)=n*(kA - \left \lfloor kA \right \rfloor)</script><script type="math/tex; mode=display">h(k)=\left \lfloor n(kA mod 1) \right \rfloor</script><h2 id="如何解决Hash冲突"><a href="#如何解决Hash冲突" class="headerlink" title="如何解决Hash冲突"></a>如何解决Hash冲突</h2><h3 id="1-链地址法"><a href="#1-链地址法" class="headerlink" title="1. 链地址法"></a>1. 链地址法</h3><p>数组 + 链表，把哈希到同一位置的所有元素都放到一个链表中，桶结构</p><p>创建一个存放单词链表的数组，数组内不直接存放单词，这样，当冲突发生时，新的数据项直接接到数组下标所指的链表中，这种方法叫做链地址法。</p><p><img src="/images/20160603152626346.png" alt=""></p><h3 id="2-开放地址法或者叫再散列法"><a href="#2-开放地址法或者叫再散列法" class="headerlink" title="2. 开放地址法或者叫再散列法"></a>2. 开放地址法或者叫再散列法</h3><p>基本思想是，当产生哈希冲突时，即关键字key的地址p=hash(key)上已经有值了，那么这次以p为基础，产生另外一个哈希地址p1,如果p1不冲突了，那么就将元素key存在位置p1,如果p1也冲突，就计算hash(p1)=p2，不冲突就存在p2,冲突继续计算；</p><p>再散列有几种方式：</p><p>1&gt;线性探测再散列：冲突发生时，查看下个位置是否空，然后遍历下去找到个空的地方存放；</p><p>2&gt;二次探测再散列：冲突发生时，在表的左右进行跳跃探测，di=12 -12 22 -22….k2 -k2;</p><p>3&gt;伪随机探测再散列：di=伪随机序列；</p><p>公式如下：</p><script type="math/tex; mode=display">Hi = (H(key) + d_i) MOD m ,  i = 1, 2, ...., s</script><p>例子：hash表长度11，哈希函数是：</p><p>h(key) = key%11;那么h(47)=3,h(26)=4,h(60)=5;下一个关键字69，h(69)=3,与47冲突了</p><p>1&gt;线性探测的解决方法：往后遍历找到个空的位置</p><pre><code>        0 1 2     3     4    5    6     7     8     9     10                 47     26   60   69 </code></pre><p>2&gt;二次探测再散列：下个哈希地址是h1 = (3+12)%11 = 4,冲突，再找下一个哈希地址，(3-12)%11 = 2，就放在第二个位置</p><p>3&gt;再看看伪随机数的处理办法，假设随机数是：2 5 9 ，下一个哈希地址（3+2）%11 = 5，冲突，再找下一个，（3+5）%11 = 8，就放在8的位置了。</p><h3 id="3-在哈希法"><a href="#3-在哈希法" class="headerlink" title="3. 在哈希法"></a>3. 在哈希法</h3><p>这种方法是同时构造多个不同的哈希函数：hi = rhi(key) i=1,2…k</p><p>当哈希地址rh1(key)冲突时，再计算hi = rh2(key)….直到不再冲突</p><h3 id="4-建立一个公共溢出区间"><a href="#4-建立一个公共溢出区间" class="headerlink" title="4. 建立一个公共溢出区间"></a>4. 建立一个公共溢出区间</h3><p>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算。这里介绍常见的几种查找算法。&lt;/p&gt;
&lt;p&gt;查找定义：根据
      
    
    </summary>
    
      <category term="笔记" scheme="http://xraorao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="http://xraorao.top/categories/%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="笔记" scheme="http://xraorao.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="http://xraorao.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>linux僵尸进程</title>
    <link href="http://xraorao.top/2018/07/11/linux%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    <id>http://xraorao.top/2018/07/11/linux僵尸进程/</id>
    <published>2018-07-11T02:52:57.000Z</published>
    <updated>2018-07-11T02:56:35.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux僵尸进程"><a href="#linux僵尸进程" class="headerlink" title="linux僵尸进程"></a>linux僵尸进程</h1><p>原因：</p><p>父进程调用fork创建子进程后，子进程运行直至其终止，它立即从内存中移除，但进程描述符仍然保留在内存中（进程描述符占有极少的内存空间）。子进程的状态变成EXIT_ZOMBIE，并且向父进程发送SIGCHLD 信号，父进程此时应该调用 wait() 系统调用来获取子进程的退出状态以及其它的信息。在 wait 调用之后，僵尸进程就完全从内存中移除。因此一个僵尸存在于其终止到父进程调用 wait 等函数这个时间的间隙，一般很快就消失，但如果编程不合理，父进程从不调用 wait 等系统调用来收集僵尸进程，那么这些进程会一直存在内存中。</p><h1 id="检测僵尸进程"><a href="#检测僵尸进程" class="headerlink" title="检测僵尸进程"></a>检测僵尸进程</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ top </span><br><span class="line">top - 09:58:31 up 3 min,  2 users,  load average: 0.76, 0.45, 0.19</span><br><span class="line">Tasks: 212 total,   1 running, 210 sleeping,   0 stopped,   1 zombie</span><br><span class="line">%Cpu(s):  6.4 us,  3.1 sy,  0.6 ni, 78.6 id, 11.2 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem:   4037576 total,  1664952 used,  2372624 free,    82416 buffers</span><br><span class="line">KiB Swap:  1998844 total,        0 used,  1998844 free.   916128 cached Mem</span><br></pre></td></tr></table></figure><p>可以看到，我们系统中有一个僵尸进程（1 zombie）。</p><h1 id="杀死僵尸进程"><a href="#杀死僵尸进程" class="headerlink" title="杀死僵尸进程"></a>杀死僵尸进程</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep -w <span class="string">'Z'</span></span><br><span class="line"><span class="comment">#或者只查看特定的栏目：</span></span><br><span class="line">$ ps -A -o <span class="built_in">stat</span>,ppid,pid,cmd | grep -e <span class="string">'^[Zz]'</span></span><br><span class="line">$ sudo <span class="built_in">kill</span> -9 ppid</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;linux僵尸进程&quot;&gt;&lt;a href=&quot;#linux僵尸进程&quot; class=&quot;headerlink&quot; title=&quot;linux僵尸进程&quot;&gt;&lt;/a&gt;linux僵尸进程&lt;/h1&gt;&lt;p&gt;原因：&lt;/p&gt;
&lt;p&gt;父进程调用fork创建子进程后，子进程运行直至其终止，它立即从
      
    
    </summary>
    
      <category term="笔记" scheme="http://xraorao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://xraorao.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="linux" scheme="http://xraorao.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法</title>
    <link href="http://xraorao.top/2018/07/11/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://xraorao.top/2018/07/11/常见排序算法/</id>
    <published>2018-07-11T00:11:05.000Z</published>
    <updated>2018-07-14T03:01:28.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ol><li>分类<br>排序算法通常指的是内部排序算法，即数据记录在内存中进行排序。</li></ol><ul><li>比较排序</li></ul><p>时间复杂度为O(nlogn) ~ O(n^2), 有冒泡排序、选择排序、 插入排序、希尔排序、归并排序、堆排序、快速排序等</p><ul><li>非比较排序</li></ul><p>时间复杂度可以达到O(n), 主要有：计数排序，基数排序，桶排序等。</p><ol><li>算法复杂度</li></ol><p><div align="center"> <img src="/images/849589-20180402133438219-1946132192.png" width=""> </div><br></p><ol><li>相关概念</li></ol><blockquote><p>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。<br>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。<br>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。<br>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 </p></blockquote><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>算法描述：从左到右，不断的交换逆序的相邻元素，在一轮的交换过后，可以让未排序的元素上浮到右侧。<br>在一轮循环中，如果没有发生交换，就说明数组已经是有序的，此时可以直接退出。</p><p><div align="center"> <img src="/images/849589-20171015223238449-2146169197.gif" width=""> </div><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> hasSorted = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span> &amp;&amp; !hasSorted; i++) &#123;</span><br><span class="line">    hasSorted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">        hasSorted = <span class="keyword">false</span>;</span><br><span class="line">        swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt; arr.length || b &lt; <span class="number">0</span> || b &gt; arr.length) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">  arr[a] = arr[b];</span><br><span class="line">  arr[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>算法描述：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><p><div align="center"><img src="/images/849589-20171015224719590-1433219824.gif" width=""> </div> <br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 选择排序</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> minIndex = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">          minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(arr, minIndex, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>算法描述：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；<br>重复步骤2~5。</li></ul><p><img src="/images/849589-20171015225645277-1151100000.gif" alt="插入排序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 插入排序</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> current = arr[i];</span><br><span class="line">      <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; current; j--) &#123;</span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 插入排序2</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 直接相邻数据交换，不需要中间变量</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; arr[j]; j--) &#123;</span><br><span class="line">        swap(arr, j - <span class="number">1</span>, j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>算法描述：简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><p>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；<br>按增量序列个数k，对序列进行k 趟排序；<br>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。<br>希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。<br>希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p><p>算法的核心在于间隔序列的设定</p><p><img src="/images/849589-20171015225645277-1151100022.gif" alt="希尔排序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = arr.length;</span><br><span class="line">  <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 动态定义间隔</span></span><br><span class="line">  <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>) &#123;</span><br><span class="line">    h = h * <span class="number">3</span> + <span class="number">1</span>; <span class="comment">// h = 1, 4, 13, 40 ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; arr[j - h] &gt; arr[j]; j -= h) &#123;</span><br><span class="line">        swap(arr, j - h, j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    h = h / <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>算法描述：归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><p><img src="/images/849589-20171015230557043-37375010.gif" alt="归并排序"></p><p><img src="/images/1216886-20171016205125521-1228601863.jpg" alt="图解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 归并排序</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">      mergeSort(arr, low, mid);</span><br><span class="line">      mergeSort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">      merge(arr, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 合并两个有序数组</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 把较小的数先移到新数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">        temp[k++] = a[i++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        temp[k++] = a[j++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把左边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">      temp[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把右边边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">      temp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把新数组中的数覆盖nums数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; temp.length; x++) &#123;</span><br><span class="line">      a[x + low] = temp[x];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>算法描述：<br>归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；<br>快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。</p><p><img src="/images/849589-20171015230936371-1413523412.gif" alt="快速排序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 快速排序</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right &lt;= left) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = partition(arr, left, right);</span><br><span class="line">    quickSort(arr, left, index - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, index + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left]; <span class="comment">// 以第一个数为基准</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="comment">// 先从后向前比较</span></span><br><span class="line">      <span class="keyword">while</span> (arr[right] &gt; pivot &amp;&amp; right &gt; left) &#123;</span><br><span class="line">        right--;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[left] = arr[right];</span><br><span class="line">      <span class="keyword">while</span> (arr[left] &lt;= pivot &amp;&amp; right &gt; left) &#123;</span><br><span class="line">        left++;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[right] = pivot;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>算法简介：堆排序指利用堆这种数据结构所设计的一种排序算法。堆是一种近似完全二叉树的结构，并满足性质：以最大堆为例，其中父节点的值总是大于它的孩子节点。</p><p>堆可以用数组来表示，因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。</p><p>流程： </p><ol><li>由输入的无序数组构造一个最大堆，作为初始的无序区</li><li>把堆顶元素（最大值）和堆尾元素互换,交换之后需要进行下沉操作维持堆的有序状态</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = arr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">    sink(arr, k, N);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    swap(arr, <span class="number">1</span>, N--);</span><br><span class="line">    sink(arr, <span class="number">1</span>, N);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; N &amp;&amp; arr[j] &lt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(arr[k] &lt; arr[j])) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, k, j);</span><br><span class="line">    k = j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>算法描述：计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>计数排序适合分布集中的排序，如统计年龄的排序等</p><p><img src="/images/849589-20171015231740840-6968181.gif" alt="计数排序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 计数排序</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; maxValue) &#123;</span><br><span class="line">        maxValue = arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    countSort(arr, maxValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> maxValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[maxValue + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> sortedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span> bucketLen = maxValue + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketLen; j++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        arr[sortedIndex++] = j;</span><br><span class="line">        bucket[j]--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>算法原理：桶排序是计数排序的升级版，利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><p>设置一个定量的数组当作空桶；<br>遍历输入数据，并且把数据一个一个放到对应的桶里去；<br>对每个不是空的桶进行排序；<br>从不是空的桶里把排好序的数据拼接起来。</p><p><img src="/images/849589-20171015232107090-1920702011.png" alt="桶排序"></p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 桶排序</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> bucketSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> minValue = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; minValue) &#123;</span><br><span class="line">        minValue = arr[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; maxValue) &#123;</span><br><span class="line">        maxValue = arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化桶</span></span><br><span class="line">    <span class="keyword">int</span> bucketCount = (<span class="keyword">int</span>) (Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = (<span class="keyword">int</span>) Math.floor((arr[i] - minValue) / bucketSize);</span><br><span class="line">      List&lt;Integer&gt; temp = buckets.get(index);</span><br><span class="line">      <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        buckets.add(index, Arrays.asList(arr[i]));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        temp.add(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buckets.size(); i++) &#123;</span><br><span class="line">      <span class="comment">//对每个桶进行排序。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>算法描述：</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><p>取得数组中的最大数，并取得位数；<br>arr为原始数组，从最低位开始取每个位组成radix数组；<br>对radix进行计数排序（利用计数排序适用于小范围数的特点）</p><p><img src="/images/849589-20171015232453668-1397662527.gif" alt="基数排序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LSD Radix Sort</span></span><br><span class="line">var counter = [];</span><br><span class="line"><span class="function">function <span class="title">radixSort</span><span class="params">(arr, maxDigit)</span> </span>&#123;</span><br><span class="line">    var mod = <span class="number">10</span>;</span><br><span class="line">    var dev = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(var j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            var bucket = parseInt((arr[j] % mod) / dev);</span><br><span class="line">            <span class="keyword">if</span>(counter[bucket]==<span class="keyword">null</span>) &#123;</span><br><span class="line">                counter[bucket] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        var pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(var j = <span class="number">0</span>; j &lt; counter.length; j++) &#123;</span><br><span class="line">            var value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(counter[j]!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> ((value = counter[j].shift()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：</p><ul><li><a href="http://www.cnblogs.com/eniac12/p/5329396.html" target="_blank" rel="noopener">常用排序算法总结(一)</a></li><li><a href="http://www.cnblogs.com/eniac12/p/5332117.html" target="_blank" rel="noopener">常用排序算法总结(二)</a></li><li><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a></li><li><a href="https://www.cnblogs.com/zhaoshuai1215/p/3448154.html" target="_blank" rel="noopener">各种排序算法总结和比较</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;分类&lt;br&gt;排序算法通常指的是内部排序算法，即数据记录在内存中进行排序。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;比较排序&lt;/l
      
    
    </summary>
    
      <category term="笔记" scheme="http://xraorao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="http://xraorao.top/categories/%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="笔记" scheme="http://xraorao.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="http://xraorao.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>chrome解决http自动跳转https的问题</title>
    <link href="http://xraorao.top/2018/07/03/chrome%E8%A7%A3%E5%86%B3http%E8%87%AA%E5%8A%A8%E8%B7%B3%E8%BD%AChttps%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://xraorao.top/2018/07/03/chrome解决http自动跳转https的问题/</id>
    <published>2018-07-03T04:06:39.000Z</published>
    <updated>2018-07-03T04:07:32.326Z</updated>
    
    <content type="html"><![CDATA[<p>1.地址栏输入： chrome://net-internals/#hsts</p><p>2.找到底部Delete domain security policies一栏，输入想处理的域名，点击delete。</p><p><img src="https://images2017.cnblogs.com/blog/37001/201712/37001-20171214102656972-118528744.png" alt="delete"></p><p>3.搞定了，再次访问http域名不再自动跳转https了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.地址栏输入： chrome://net-internals/#hsts&lt;/p&gt;
&lt;p&gt;2.找到底部Delete domain security policies一栏，输入想处理的域名，点击delete。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images20
      
    
    </summary>
    
      <category term="笔记" scheme="http://xraorao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://xraorao.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>lvm磁盘合并</title>
    <link href="http://xraorao.top/2018/07/03/lvm%E7%A3%81%E7%9B%98%E5%90%88%E5%B9%B6/"/>
    <id>http://xraorao.top/2018/07/03/lvm磁盘合并/</id>
    <published>2018-07-03T04:05:07.000Z</published>
    <updated>2018-07-03T04:06:03.670Z</updated>
    
    <content type="html"><![CDATA[<ul><li>显示逻辑卷组<br>sudo vgdisplay</li><li>显示逻辑卷<br>sudo lvdisplay</li><li>显示磁盘<br>sudo fdisk -l</li><li>创建物理卷<br>sudo pvcreate /dev/sdb</li><li>显示物理卷信息<br>sudo pvdisplay</li><li>物理卷/dev/sdb加入卷组vg-root<br>sudo vgextend vg-root /dev/sdb</li><li>增大逻辑卷root 1T<br>sudo lvextend -L +1T /dev/ubuntu-vg/root<br>sudo lvextend -l +100%FREE /de/ubuntu-vg/root</li><li>调整文件系统大小<br>sudo resize2fs /dev/ubuntu-vg/root</li><li>查看结果<br>df -h </li></ul><p>issue:</p><ol><li><a href="https://serverfault.com/questions/319427/how-to-remove-bad-disk-from-lvm2-with-the-less-data-loss-on-other-pvs" target="_blank" rel="noopener">remove bad disk</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;显示逻辑卷组&lt;br&gt;sudo vgdisplay&lt;/li&gt;
&lt;li&gt;显示逻辑卷&lt;br&gt;sudo lvdisplay&lt;/li&gt;
&lt;li&gt;显示磁盘&lt;br&gt;sudo fdisk -l&lt;/li&gt;
&lt;li&gt;创建物理卷&lt;br&gt;sudo pvcreate /dev/sdb&lt;/
      
    
    </summary>
    
      <category term="笔记" scheme="http://xraorao.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://xraorao.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="linux" scheme="http://xraorao.top/tags/linux/"/>
    
  </entry>
  
</feed>
